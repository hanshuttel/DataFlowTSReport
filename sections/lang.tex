\documentclass[../../master.tex]{subfiles}
\begin{document}
\section{Language}\label{sec:lang}
In this section, we will present a subset of ReScript, which is based on the OCaml family.
The language introduced, contains the typical lambda expressions, bindings, pattern matching, and mutability.
For the purpose of the type system that will be presented later, we also extends to language with program points, such that each expression has its own unique program point, which we call syntactic occurrences.

The occurrences is used in the type system to analyse and distinguish between expressions, where there is syntactic occurrences, that is expressions, and semantic occurrences, those are variables and locations.

\subsection{Abstract syntax}
In this section we will introduce the abstract syntax, based on (previous paper), with some notable changes.
We reintroduce the syntactic categories as the previous paper, that is, \cat{Con} denotes the category of constants and \cat{Exp} denotes the category of expressions.
Where $c \in \cat{Con}$ and $e\in\cat{Exp}$.

We introduce a syntactic category for terms, denoted as $t\in\cat{Term}$, and a syntactic category for locations, denoted as $\loc\in\cat{Loc}$.
The syntactic categories for variables is changed, compared to there previous paper, such that there are placeholder and imperative variables.
The placeholder variables, denoted \cat{Var}, are variables from abstractions and imperative variables, denoted \cat{IVar}, are from bindings.
We denote identifiers, in the language, as an union of placeholder and imperative variables, denoted $\cat{Id}=\cat{Var}\cup\cat{IVar}$, where we then have $x,\;f\in\cat{Id}$.
The syntactic category for program point are denoted as $p\in\cat{P}$.
\bigskip

As explained earlier, the language presented here introduces the notion of occurrences.
We firstly introduce a notion of labelling for expressions, identifiers and locations, where we write $e^p$ for expressions labelled with a program point, and are similar to identifiers and locations.
We further also introduce a notion for categories and sets that represent occurrences, where they are labelled with the category for program points \cat{P}, i.e., for expressions \cat{Exp}, we then have the category for expression occurrences $e^p\in\cat{Exp}^P$.

We can then properly define the occurrences, where we introduce 2 types of occurrences, that is, for syntactical occurrences, denoted as $e^p\in\cat{Exp}^P$, and semantical occurrences.
The semantical occurrences is further divided into two types, for identifiers and locations and denoted as $x^p,\;f^p\in\cat{Id}^P$ and $\loc^p\in\cat{Loc}^P$ respectively.

The formation rules is then defined, as in \cref{fig:coresyntax}:

\begin{figure}[H]
	\begin{minipage}[t]{0.45\textwidth}
		\setlength\tabcolsep{4pt}
		\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
			term \; t &::= &e^p \\\\

			expression \; e &::= &x \mid c \mid t_1\;t_2 \mid \lambda x.t\\
			&| &\mbox{let} \; x \; t_1 \; t_2 \\
			&| &\mbox{let rec} \; x \; t_1 \; t_2 \\
			&| &\mbox{case} \; t_1 \; \{\pi\} \\
			&| &\mbox{ref} \; t \mid t_1 := t_2 \mid \; !t\\\\

			Patterns \; \pi &::= &(s\;t)\mid(s\;t)\;\pi\\\\

			Pattern \; s &::= &n \mid b \mid x \mid \_ \\
		\end{tabular}
	\end{minipage}
	\begin{minipage}[t]{0.45\textwidth}
		\setlength\tabcolsep{4pt}
		\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
			Constant\; c &::= &n \mid b\\
			&| &PLUS \\
			&| &MINUS \\
			&| &TIMES\\
			&| &TIMES \\
			&| &EQUAL \\
			&| &LESS\\
			&| &GREATER\\
			&| &NOT \\ \\
		\end{tabular}
	\end{minipage}
	\caption{Abstract syntax}
	\label{fig:coresyntax}
\end{figure}

Most of these formation rules are similar to (previous paper) there are, however, some changes made in regards to how pattern matching is presented.
Some of the notable constructs is further explained below.

\paragraph{Constants}
The constants are either natural numbers $n$, boolean values $b$, or functional constants.
For each functional constant we introduce a function $apply$, that for each constant returns the result of applying a constant to its arguments.
Note that, for functional constant that take two or more arguments, $apply$ should be used twice, such that, as an example for $PLUS$ we have:
$$apply(apply(PLUS,2),2)=2+2$$

\paragraph{Abstractions}
denotes functions with a parameter $x$ and body $t$, where $x\in\Var$.
Here, abstractions use juxtaposition of expressions, where abstractions have exactly one argument.

\paragraph{bindings}
are immutable and are done through local declaration, which can be recursive or non-recursive by the use of the $rec$ keyword.
A binding is done on placeholder variables, such that $x,\;f\in\IVar$.
Here, if $\mbox{let}\;x\;t_1\;t_2$ has an occurrence of $x$ in $t_1$ it is not treated as a recursive call to $x$ and $x$ should thus be specified elsewhere.
If we add the $rec$ keyword, then if $x$ appears in $t_1$, it should thus be treated as a recursive call to $x$.

\paragraph{Mutability}
The mutability is handled as references, that is, for the constructs $\mbox{ref}\;t$, $t_1\;:=\;t_2$, and $!t$, for declaring a new location, writing to a location, or reading from a location, respectively.
These constructs wraps the mutability to a semantic construct for locations, which are handled on runtime.
Note that, even though bindings are immutable, a variable can still be bound to a location.
This does not make the variable mutable, as it will then be bound to this location, and cannot be bound to another value or location.

\paragraph{Pattern matching}
The pattern matching construct matches a term $t$ with the pattern in $\pi$.
The pattern matching is done by matching on each pattern, until a match is found, in the order given by the syntax.
A pattern is of the form $(s\;t)$, with at least one pattern.
We also denote $|\pi|$ as the number of pattern that occurs in $\pi$.

\subsection{Semantics}\label{sec:sem}
We will now introduce the big-step semantics extended with the collection of occurrence dependencies.
The collection of occurrence dependencies is done through the dependency function $w$, defined as:
$$w:\Var^P\cup\IVar^P\cup\Loc^P\rightharpoonup\Pow{\Loc^P\times\Var^P\cup\IVar^P}$$
A lookup in the dependency function are $w(x^p)=(\{\loc^{p_1},\cdots,\loc^{p_n}\},x_1^{p'_1},\cdots,x_y^{p'_y})$.
In the rest of the paper, we will denotes the dependency pair by $(L,V)$, where $L$ is a set of location occurrences and $V$ is the set of variable occurrences.

With the dependency function defined, we can now present the transition system, which is similarly defined in (previous paper), and are of the form:
\begin{align*}
env\vdash\left\langle e^{p'},sto,w,p\right\rangle\rightarrow\left\langle v,sto',w',(L,V),p''\right\rangle
\end{align*}
Where $env\in\Env$ and $sto\in\Sto$
This should be read as, given the store $sto$, dependency function $w$, and the previous program point $p$, the syntactic occurrence $e^{p'}$ evaluates to a value $v$, an updated store $sto'$, an updated dependency function $w'$, the liveness pair $(L,V)$, and the program point $p''$ reached after evaluating $e^{p'}$, given the bindings in the environment $env$.

The environment keeps the bindings currently known, such that:
$$\Env=\Var\cup\IVar\rightharpoonup\Val$$

The store keeps the location bindings known and a placeholder $next$ that represent the next free location.

$$\Sto=\Loc\cup\{next\}\rightharpoonup\Val$$

Where $\Val$ is similarly defined, as in (previous paper):
\begin{itemize}
	\item All constants are values.
	\item Locations are values.
	\item Closures, \InfVal{x,e,env} are values.
	\item Recursive closures, \InfVal{f,x,e,env}, are values.
	\item Unit values, $()$, are values.
\end{itemize}
In other words, we have
\begin{align*}
	&\Val=\Con\cup\Loc\cup(\Var\cup\IVar)\times\Exp\times\Val\cup\\
	&(\Var\cup\IVar)\times(\Var\cup\IVar)\times\Exp\times\Val\cup()
\end{align*}

We, similarly to (prev paper), assume the existence of a function $new:\Loc\rightharpoonup\Loc$, which takes a location and finds the next location.
This function is only used on the $next$ location placeholder to find the next free location, i.e. a location that is not already bound in $sto$.

Note that, in the semantics we refer to syntactic occurrences, $e^p$, directly instead of terms.
This is done, as will be obvious later, to directly refer to program points.

Before introducing some transition rules, we first need to introduce a function that for a given semantical occurrence, $x^p$ or $\loc^p$, finds the closest semantical occurrence.
It should be noted that, for an occurrence $x^p$, the closest occurrence should be for the same variable, and the same holds for locations.

\begin{definition}[$inf_p$ function]
	Let $x^p$ be a semantical occurrence and $w$ be a dependency function, then $inf_p(x^p,w)=x^{p'}$ is as follows:
	\begin{align*}
		inf_p(x^p,w)=\forall x^{p''}\in dom(w). p''<p\Rightarrow \exists x^{p'}\in dom(w).p''<p\wedge p'<p''
	\end{align*}
\end{definition}
\bigskip

Only a couple of interesting transition rules will be shown here, the rest can be found in \cref{App:ColSem}.
The first transition rule, $\runa{Con}$, is the simplest rule that shows part of the transition system.
Here, as a constant is directly evaluated there is no side effects, the pair $(L,V)$ is empty, and the program point reached after evaluating $c^p$ is $p$.

\todo[inline]{$\runa{Var}$ description needs a rewrite}
In the second rule, $\runa{Var}$, the environment and dependency function comes into play, as the value and dependencies of the variable needs to be looked up.
The value for the variable is easy, as it is directly looked up in the environment.
To get the dependencies of a variable, the closest occurrence needs to be found first.
This is done through the $inf_p$ function, which finds the closest occurrence for the same variable in $w$, and returns the program point.
With the given program point, the dependencies for this variable, at the given program point, can be looked up in $w$.
Since the variable occurrence, $x^{p'}$, is used, it is added to the set of variable occurrences.

The third rule, $\runa{let}$, is for when a local declaration is reached, here we add the information from the local declaration in both the environment and dependency function.
The dependency function is updated with the liveness pair from evaluating the local declaration for the variable occurrence $x^{p'}$, where the program point is the point reached after evaluating the local declaration.

The next two rules shown, $\runa{Loc new}$ and $\runa{Loc write}$, are for handling creating a new reference and writing to a reference.
The $\runa{Loc new}$ rule evaluated the body to a value $v$ and returns a location.
This location, $\loc$, is retrieved from the placeholder location $next$ in $sto$ and $\loc$ is bound to $v$ in $sto$.
The dependency function is also updated with the liveness information from evaluating the body, and is bound to the occurrence for $\loc$ at the program point $p''$.

For $\runa{Loc write}$, first the two terms are evaluated, where first term needs to be a location.
The location $\loc$ is bound to the value from evaluating the second term, in $sto$ and the $w$ is updated with the liveness pair from the second term, to the occurrence for $\loc$ at point $p_3$.
Since the value of a write expression, in ReScript, does not return a value, the value returned here is the unit value $()$.


\begin{figure}[H]
	\setlength\tabcolsep{8pt}
	\begin{tabular}{l}
		\InfName{Const}\\[0.2cm]
			\inference[]{}
				{env\vdash \left\langle c^{p'},sto,w,p \right\rangle \rightarrow \left\langle c,sto,w,(\emptyset,\emptyset),p' \right\rangle}\\[1cm]
			
		\InfName{Var}\\[0.2cm]
			\inference[]{}
				{env\vdash \left\langle x^{p'},sto,w,p \right\rangle \rightarrow \left\langle v,sto,w,(L,V\cup\{x^{p'}\}),p' \right\rangle}\\
				Where $env(x)=v$, $p''=\inf_{p} (x^{p'},w)$, and $w(x^{p''})=(L,V)$\\[1cm]

		\InfName{Let}\\[0.2cm]
			\inference[]
			{env\vdash \left\langle e_1^{p'},sto,w,p \right\rangle \rightarrow \left\langle v,sto',w',(L,V),p' \right\rangle &\\
			env[x\mapsto v]\vdash \left\langle e_2^{p''},sto',w'',p' \right\rangle \rightarrow \left\langle v',sto'',w_3,(L',V'),p'' \right\rangle}
			{env\vdash \left\langle [\mbox{let}\;x\;e_1^{p'}\;e_2^{p''}]^{p_3},sto,w,p \right\rangle \rightarrow \left\langle v',sto'',w_3,(L',V'),p_3 \right\rangle}\\
		Where $w''=w'[x^{p'}\mapsto(L,V)]$\\[1cm]

		\InfName{Loc\;new}\\[0.2cm]
			\inference[]
				{env \vdash \left\langle e^{p'},sto,w,p \right\rangle \rightarrow \left\langle v,sto',w',(L,V),p' \right\rangle}
				{env\vdash \left\langle [\mbox{ref}\;e^{p'}]^{p''},sto,w,p \right\rangle \rightarrow \left\langle \loc,sto''[\loc\mapsto v],w'',(L,V),p'' \right\rangle}\\
			Where $\loc = next$, $sto''=sto'[next\mapsto new\;\loc]$ and $w''=w'[\loc^{p''}\mapsto (L,V)]$\\[1cm]

		\InfName{Loc\;read}\\[0.2cm]
			\inference[]
				{env \vdash \left\langle e^{p'},sto,w,p \right\rangle \rightarrow \left\langle \loc,sto',w',L,V,p' \right\rangle}
				{env\vdash \left\langle [!e^{p'}]^{p''},sto,w,p \right\rangle \rightarrow \left\langle v,sto',w',L\cup\{\loc^{p''}\},V,p'' \right\rangle}\\
			Where $sto'(\loc)=v$\\[1cm]


		\InfName{Loc\;write}\\[0.2cm]
			\inference[]
				{env \vdash \left\langle e_1^{p'},sto,w,p \right\rangle \rightarrow \left\langle \loc,sto',w',(L,V),p' \right\rangle &\\
				env \vdash \left\langle e_2^{p''},sto',w',p' \right\rangle \rightarrow \left\langle v,sto'',w'',(L',V'),p'' \right\rangle}
				{env\vdash \left\langle [e_1^{p'}:=e_2^{p''}]^{p_3},sto,w,p \right\rangle \rightarrow \left\langle (),sto_3,w_3,(L,V),p_3 \right\rangle}\\
				Where $sto_3=sto''[\loc\mapsto v]$ and $w_3=w''[\loc^{p_3}\mapsto(L',V')]$\\[1cm]
	\end{tabular}
	\caption{Collection semantics}
	\label{fig:ColSem}
\end{figure}
\end{document}
