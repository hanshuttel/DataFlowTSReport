\documentclass[../../master.tex]{subfiles}
\begin{document}
\section{Language}\label{sec:lang}
In this section, we will now present a functional subset of ReScript, based on the OCaml family.
The language introduced, contains the typical lambda expressions, bindings, pattern matching, and mutability.
For the purpose of the type system that will be presented later, we also extends to language with program points, such that each expression has its own unique program point, which we call syntactic occurrences.

The occurrences is used in the type system to analyse and distinguish between expressions, where there is syntactical occurrences, that is expressions, and semantical occurrences, those are variables and locations.

\subsection{Abstract syntax}
In this section we will introduce the abstract syntax, based on (previous paper), with some notable changes.
We reintroduce the syntactical categories as the previous paper, that is, $\Con$ denotes the category of constants, $\Val$ denotes the category of values, and $\Exp$ denotes the category of expressions.
Where $e, \; m \in \Exp$ and $c \in \Con$.

The syntactic categories for variables is changed, where we now have $\Var$ denotes the category for placeholder variables, that is variables from $\lambda$-abstractions, and $\IVar$ denotes the category for imperative variables, variables from binding expressions.
The syntactic category $\Loc$ denotes the category for locations, and $\Point$ that denotes the category for program point labels.
We then have $x,\;f\in(\Var\cup\IVar)$, $\loc\in\Loc$, and $p,\;p',\;p'',p_1,\cdots,p_n\in\Point$.

The formation rules is then defined, in \cref{fig:coresyntax}:

\begin{figure}[H]
	\begin{minipage}[t]{0.45\textwidth}
		\setlength\tabcolsep{4pt}
		\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
			term \; t &::= &e^p \\\\

			expression \; e &::= &x \mid c \mid t_1\;t_2 \mid \lambda x.t\\
			&| &\mbox{let} \; x \; t_1 \; t_2 \\
			&| &\mbox{let rec} \; x \; t_1 \; t_2 \\
			&| &\mbox{case} \; t_1 \; \{\pi\} \\
			&| &\mbox{ref} \; t \mid t_1 := t_2 \mid \; !t\\\\

			Patterns \; \pi &::= &(s\;t)\mid(s\;t)\;\pi\\\\

			Pattern \; s &::= &n \mid b \mid x \mid \_ \\
		\end{tabular}
	\end{minipage}
	\begin{minipage}[t]{0.45\textwidth}
		\setlength\tabcolsep{4pt}
		\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
			Constant\; c &::= &n \mid b\\
			&| &PLUS \\
			&| &MINUS \\
			&| &TIMES\\
			&| &TIMES \\
			&| &EQUAL \\
			&| &LESS\\
			&| &GREATER\\
			&| &NOT \\ \\
		\end{tabular}
	\end{minipage}
	\caption{Abstract syntax}
	\label{fig:coresyntax}
\end{figure}

Most of these formation rules are similar to (previous paper) there are, however, some changes made in regards to how pattern matching is presented.
Some of the notable constructs is further explained below.

\paragraph{Constants}
The constants is either natural numbers $n$, boolean values $b$, or functional constants.
For each functional constant we introduce a function $apply$, that for each constant returns the result of applying a constant to its arguments.
Note that, for functional constant that take two or more arguments, $apply$ should be used twice, such that, as an example for $PLUS$ we have:
$$apply(apply(PLUS,2),2)=2+2$$

\paragraph{Abstractions}
$\lambda$-abstractions denotes functions with a parameter $x$ and body $t$.
Here, abstractions use juxtaposition of expressions, where abstractions have exactly one argument.

\paragraph{bindings}
Bindings are immutable and is done through local declaration, which can be recursive or non-recursive by the use of the $rec$ keyword.
A binding is done on placeholder variables, such that $x,\;f\in\IVar$.
Here, if $\mbox{let}\;x\;t_1\;t_2$ has an occurrence of $x$ in $t_1$ it is not treated as a recursive call to $x$ and $x$ should thus be specified elsewhere.
If we add the $rec$ keyword, then if $x$ appears in $t_1$, it should thus be treated as a recursive call to $x$.

\paragraph{Mutability}
The mutability is handled as references, that is, for the constructs $\mbox{ref}\;t$, $t_1\;:=\;t_2$, and $!t$, for declaring a new location, writing to a location, or reading from a location, respectively.
These constructs wraps the mutability to a semantical construct for locations, which are handled on runtime.
Note that, even though bindings are immutable, a variable can still be bound to a location.
This does not make the variable mutable, as it will then be bound to this location, and cannot be bound to another value or location.

\paragraph{Pattern matching}
The pattern matching construct matches a term $t$ with the pattern bindings in $\pi$.
The pattern matching is done by matching on each pattern, until a match is found, in the order given by the syntax.
A pattern binding is of the form $(s\;t)$, with at least one pattern binding.
We also denote $|\pi|$ as the number of pattern bindings.

\subsection{Semantic}



\end{document}
