\documentclass[../../master.tex]{subfiles}
\begin{document}
\section{Language}\label{sec:lang}
This section will introduce a functional programming language, based on a subset of ReScript.
The language presented here is basically a $\lambda$-calculus with bindings, pattern matching and mutability.
As the purpose of the dependency analysis is to analyse each subexpression of a program and differentiate them, the language is extended to label all expressions and subexpression.
For the sake of the rest of the paper, we call the label a program point.
When labelling a syntactical element or semantical element, we call it an occurrence, such that the syntactical occurrences makes up the program, an is thus labelled expressions, while semantical occurrences are then variables and locations.

The language we present here, we assume that all local bindings, including recursive bindings, are unique.
This can also be ensured by using $\alpha$-conversion.
We also make a distinction between labelled and unlabelled expressions, such that an occurrence is a labelled expression, and unlabelled expressions are just called expressions.

In this section will first formally introduce the abstract syntax for the language, and then the semantics.
The semantics introduced here is an operational big-step semantics where we add the notion of program points and a mechanism for collecting dependencies.

\subsection{Syntax}
This section introduces the abstract syntax of the language, based on the one presented in \cite{DVNicky}.
The syntactic categories for the language is defined as:

\begin{align*}
	p\in &\;\cat{P} &-\;&\mbox{The category for program points} \\
	e\in &\;\cat{Exp} &-\;&\mbox{The category for expressions, or unlabelled terms} \\
	o\in &\;\cat{Occ} &-\;&\mbox{The category for occurrences, or labelled expressions} \\
	c\in &\;\cat{Con} &-\;&\mbox{The category for constants} \\
	x,\;f\in &\;\cat{Var} &-\;&\mbox{The category for variables} \\
	\loc\in &\;\cat{Loc} &-\;&\mbox{The category for constants}
\end{align*}

We also introduce a notation for occurrences of categories where, for a category $cat$, we write $cat^\cat{P}$ denoting the pair $cat\times\cat{P}$, i.e., for expression occurrences we then have $\cat{Exp}^\cat{P}=\cat{Exp}\times\cat{P}$.

Since the category for occurrences are labelled expressions, it can further be defined as:
$$\cat{Occ}=\cat{Exp}^\cat{P}$$

The formation rules is presented in \cref{fig:coresyntax}.

\todo[inline]{Rename terms to occurrences}

\begin{figure}[H]
	\begin{minipage}[t]{0.45\textwidth}
		\setlength\tabcolsep{4pt}
		\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
			Occurrence \; o &::= &e^p \\\\

			expression \; e &::= &x \mid c \mid o_1\;o_2 \mid \lambda x.o\\
			&| &\mbox{let} \; x \; o_1 \; o_2 \\
			&| &\mbox{let rec} \; x \; o_1 \; o_2 \\
			&| &\mbox{case} \; o_1 \; \tilde{\pi} \; \tilde{o}\\
			&| &\mbox{ref} \; o \mid o_1 := o_2 \mid \; !o\\\\

			Patterns		\; \tilde{\pi} &::= &(s_1,\cdots,s_n)\\
			Occurrences \; \tilde{o} &::= &(e_1^{p_1},\cdots,e_n^{p_n})\\\\

			Pattern \; s &::= &n \mid b \mid x \mid \_ \\
		\end{tabular}
	\end{minipage}
	\begin{minipage}[t]{0.45\textwidth}
		\setlength\tabcolsep{4pt}
		\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
			Constant\; c &::= &n \mid b\\
			&| &PLUS \\
			&| &MINUS \\
			&| &TIMES\\
			&| &TIMES \\
			&| &EQUAL \\
			&| &LESS\\
			&| &GREATER\\
			&| &NOT \\ \\
		\end{tabular}
	\end{minipage}
	\caption{Abstract syntax}
	\label{fig:coresyntax}
\end{figure}

Some notable constructs is further explained below.
\begin{description}
	\item[Abstractions] $\lambda\;x.o$ denotes functions with a parameter $x$ and body $o$.
		Applications uses juxtaposition, where abstractions have exactly one argument.

	\item[Constants] $c$ are either natural numbers $n$, boolean values $b$, or functional constants.
		We introduce a function $apply$, that for each functional constant returns the result of applying a constant $c$ to its arguments.
		Since we use juxtaposition, we will do the same for $apply$, such that if a functional constant takes more than one argument, we then need to use apply twice, such that for $PLUS$ we have:
		$$apply(apply(PLUS,2),2)=2+2$$

	\item[Bindings] $\mbox{let} \; x \; o_1 \; o_2$ and $\mbox{let rec} \; x \; o_1 \; o_2$, also called local declarations, are immutable bindings that binds variables to values.
		We introduce two constructs for bindings which are recursive or non-recursive bindings.

	\item[Mutability] is a construct that allows for mutable constructs through referencing.
		The referencing uses locations and introduces constructs for creating, writing, and reading references.
		This, however, does not make bindings mutable, since a bindings will always be bound to the same value, where the referencing constructs are wrappers for the locations.

	\item[Pattern matching] $\mbox{case} \; o_1 \; \tilde{\pi} \; \tilde{o}$, matches an occurrence with the ordered set, $\tilde{\pi}$, of patterns.
		For each pattern in $\tilde{\pi}$ there is also an occurrence in $\tilde{o}$, as such both the set of patterns and the set of occurrences must be the same size.
		We also denote the size of patterns as $|\tilde{\pi}|$ and the size of occurrences as $|\tilde{o}|$.
\end{description}

\begin{example}[]
The following program:
\begin{lstlisting}[language=Caml, mathescape=true]
(let x ($\lambda$ y.((PLUS$^1$ y$^2$)$^3$ 1$^4$)$^5$)$^6$ (x$^7$ (x$^8$ 1$^9$)$^{10}$)$^{11}$)$^{12}$
\end{lstlisting}
First, binds the variable $x$ to a function that takes a constant as parameter and adds 1 to it.
Second, it applies $1$ to $x$ and applies the result to $x$ again.
\end{example}

\todo[inline]{Add an example that demonstrate \runa{Case} and maybe also \runa{Ref}}

\todo[inline]{Insert ref to proof section}
Later on, in (insert ref), we make use of the notion of free variables, which are defined in the usual way for $\lambda$-calculus and are as follows:
\begin{definition}[Free variables]\label{def:fv}
	The set of free variables is a function $fv:\cat{Term}\rightarrow\Pow{\cat{Var}}$, given inductively by:
	\begin{align*}
		fv(x^p)&=\{x\}\\
		fv(c^p)&=\emptyset\\
		fv([\lambda\;y.e^{p'}]^p)&=fv(e^{p'})\backslash\{y\}\\
		fv([e_1^{p_1}\;e_2^{p_2}]^p)&=fv(e_1^{p_1})\cup fv(e_2^{p_2})\\
		fv([\mbox{let}\;y\;e_1^{p_1}\;e_2^{p_2}]^p)&=fv(e_1^{p_1})\cup fv(e_2^{p_2})\backslash\{y\}\\
		fv([\mbox{let rec}\;f\;e_1^{p_1}\;e_2^{p_2}]^p)&=fv(e_1^{p_1})\cup fv(e_2^{p_2})\backslash\{f\}\\
		fv([\mbox{case}\;e^{p'}\;(s_1,\cdots,s_n)\;(e_1^{p_1},\cdots,e_n^{p_n})]^p)&=fv(e^{p'})\cup fv(e_1^{p_1})\cup\cdots\cup fv(e_n^{p_n})\backslash(\tau(s_1)\cup\cdots\cup\tau(s_n))\\
		fv([\mbox{ref}\;e^{p'}]^p)&=fv(e^{p'})\\
		fv([!e^{p'}]^p)&=fv(e^{p'})\\
		fv([e_1^{p_1}\;:=\;e_2^{p_2}]^p)&=fv(e_1^{p_1})\cup fv(e_2^{p_2})\\
	\end{align*}
	where $\tau(s)$, for a pattern $s$, is denoted as:
	$$
	\tau(s)=
		\left\{\begin{matrix}
			\{x\} & \mbox{if}\;s=x\\ 
			\emptyset & \mbox{otherwise}
		\end{matrix}\right.
	$$
\end{definition}

\iffalse
\begin{definition}[Bound variables]\label{def:bv}
	The set of bound variables is given by:
	\begin{align*}
		bv(x^p)&=\emptyset\\
		bv(c^p)&=\emptyset\\
		bv([\lambda\;y.e_1^{p'}]^p)&=bv(e_1^{p'})\cup\{y\}\\
		bv([e_1^{p'}\;e_2^{p''}]^p)&=bv(e_1^{p'})\cup bv(e_2^{p''})\\
		bv([\mbox{let}\;y\;e_1^{p'}\;e_2^{p''}]^p)&=bv(e_1^{p'})\cup bv(e_2^{p''})\cup\{y\}\\
		bv([\mbox{let rec}\;f\;e_1^{p'}\;e_2^{p''}]^p)&=bv(e_1^{p'})\cup bv(e_2^{p''})\cup\{f\}\\
		bv([\mbox{case}\;e^{p'}\;\pi^{p''}]^p)&=bv(e_1^{p'})\cup bv(\pi)\\
		bv([(s\;e^{p'})\;\pi])&=bv(e^{p'})\cup bv(\pi)\cup\tau(s)\\
		bv([(s\;e^{p'})])&=bv(e^{p'})\cup\tau(s)\\
		bv([\mbox{ref}\;e^{p'}]^p)&=bv(e^{p'})\\
		bv([!e^{p'}]^p)&=bv(e^{p'})\\
		bv([e_1^{p'}\;:=\;e_2^{p''}]^p)&=bv(e_1^{p'})\cup bv(e_2^{p''})\\
	\end{align*}
\end{definition}
\fi

\subsection{Environments and stores}\label{sec:EnvSto}
We will now introduce the environments and stores used by the semantics, introduced in \cref{sec:sem}.
Since the language we focus on introduces mutability, through the referencing wrappers, this needs to be reflecting in our bindings model.
Here, the referencing wrappers can also be seen as how locations, or pointers, are created and handled, where we introduce stores to describe how they are bound.

Since this language is a functional language, the environment keeps the bindings we currently know, as such the environment is a function from variables to values.
The set of values, \cat{Values}, is comprised by:
\begin{itemize}
	\item All constants are values.
	\item Locations are values.
	\item Closures, \InfVal{x,e,env} are values.
	\item Recursive closures, \InfVal{f,x,e,env}, are values.
	\item Unit values, $()$, are values.
\end{itemize}

A value $v\in\cat{Values}$ is an expression given by the following formation rules:
$$v::=c\mid\loc\mid\left\langle x^{p},e^{p'},env\right\rangle\mid\left\langle x^{p},f^{p'},e^{p''},env\right\rangle\mid ()$$

\begin{definition}[]
	The set of all Environments, \cat{Env}, is the set of partial functions from variables to values, given as:
	$$\cat{Env}=\cat{Var}\rightharpoonup\cat{Values}$$
\end{definition}
Where $env\in\cat{Env}$ denotes an arbitrary environment in \cat{Env}.

\begin{definition}[Update of environments]
	Let $env$ be an environment, we write $env[x\mapsto v]$ to denote the environment $env'$ where:
	\begin{align*}
		env'(y)=
		\left\{\begin{matrix}
			env(y) & \mbox{if}\;y\neq x\\\	 
			v & \mbox{if}\;y=x
		\end{matrix}\right.
	\end{align*}
\end{definition}

We also introduce a function which, for a given value $v$, returns all variables that is bound to $v$.
\begin{definition}[inverse env]
	Let $v$ be a value and $env\in\cat{Env}$ be an environment, the inverse function $env^{-1}$ is then given as:
$$env^{-1}:\cat{Values}\rightarrow\Pow{Var}$$
\end{definition}

The store is a function, that keeps the location bindings currently known.
We also introduce a placeholder $next$, that represents the next free location.
The store function is then given by:

\begin{definition}[]
	The set of all stores, \cat{Sto}, is the set of partial functions from locations, and the $next$ pointer, to values, given as:
	$$\cat{Sto}=\cat{Loc}\cup\{next\}\rightharpoonup\cat{Values}$$
\end{definition}
Where $sto\in\cat{Sto}$ denotes an arbitrary store in \cat{Sto}.

\begin{definition}[Update of stores]
	Let $sto$ be a store, we write $sto[\loc\mapsto v]$ to denote the store $sto'$ where:
	\begin{align*}
		sto'(\loc_1)=
		\left\{\begin{matrix}
			env(\loc_1) & \mbox{if}\;\loc_1\neq \loc\\\	 
			v & \mbox{if}\;\loc_1=\loc
		\end{matrix}\right.
	\end{align*}
\end{definition}

We also assume the existence of a function $new:\cat{Loc}\rightarrow\cat{Loc}$, which takes a location and finds the next location.
This function is primarily used on the placeholder pointer $next$ to find a new location, which is not already bound in our store.



\subsection{Dependencies}\label{sec:DepFunc}
\todo[inline]{Look at this intro text again}
The goal of the collection semantics is to collect the semantic dependencies as they appear in a computation. To this end, we use a dependency function that will tell us for each variable and location occurrence what other, previous occurrences they depend upon.

\begin{definition}[Dependency function]\label{def:DepFunc}
	The set of dependency functions, $\cat{W}$, is a set of partial functions from location and variable occurrences to a dependency pair, such that:
	$$\cat{W}=\cat{Loc}^P\cup\cat{Var}^P\rightharpoonup\Pow{\cat{Loc}^P}\times\Pow{\cat{Var}^P}$$
\end{definition}
A lookup in a dependency function $w$ is, for a $u^p\in\cat{Loc}^P\cup\cat{Var}^P$, such that:
$$w(u^p)=(\{\loc_1^{p_1},\cdots,\loc_n^{p_n}\},\{x_1^{p'_1},\cdots,x_m^{p'_m}\})$$
This should be read as: a lookup of an occurrence $u^p$, that is for a variable or location occurrence, returns a pair of location occurrences and a set of variable occurrences.
We also denote the pair, retrieved from the dependency function, as a dependency pair where $(L,V)$ where $L=\{\loc_1^{p_1},\cdots,\loc_n^{p_n}\}$ is the set of location occurrences and $V=\{x_1^{p'_1},\cdots,x_m^{p'_m}\}$ is the set of variable occurrences.

\begin{definition}[Update of $w$]\label{def:DepExt}
	Let $w\in\cat{W}$ be a dependency function, we write $w[u^p\mapsto(L,V)]$ to denote the dependency function $w'$ where:
	\begin{align*}
		w'(v^q)=
		\left\{\begin{matrix}
			w(v^q) & \mbox{if}\;v^q\neq u^p\\\	 
			(L,V) & \mbox{if}\;v^q=u^p
		\end{matrix}\right.
	\end{align*}
\end{definition}

To denote an ordering of program points, we introduce a binary relation of program points:

\begin{definition}[Occurring program points]\label{def:RelPoint}
	Let $O$ be a set of occurrences, then $points(O)$ is given by:
	$$points(O)=\{p\in\cat{P}\mid\exists e^p\in O\}$$
\end{definition}
We assume that, in the following, that there exists a partial order, $\sqsubseteq$, of program points.

\begin{definition}[]\label{def:RelPoint}
	Let $w\in\cat{W}$ be a dependency function.
	Then $\sqsubseteq_w$ is given by:
	$$\sqsubseteq_w\subseteq\{(p,p')\mid p,p'\in(points(dom(w))\cup points(ran(w)))\}$$
\end{definition}
We say that $w$ is a partial order, with right to, $\sqsubseteq$ if $\sqsubseteq_w$ is a partial order.
We also denote the pair of a dependency function $w\in\cat{W}$ and the order on $\sqsubseteq_w$ as $\psi=(w,\sqsubseteq_w)$.

\iffalse
\begin{definition}[Relation of program points]\label{def:RelPoint}
	Let \cat{P} be a set of program points, we say that:
	$$\sqsubseteq\subseteq\cat{P}\times\cat{P}$$
	is a binary relation over program points.
\end{definition}
We denote $(p',p'')\in\sqsubseteq$ as $p'\sqsubseteq p''$ and we also denote that $\sqsubseteq_w$ is a relation of program points over a dependency function $w\in\cat{W}$, i.e., the relation $\sqsubseteq_w$ only contains program points that exists either in the domain or co-domain of $w$. 

We also define $\psi\in\Psi$ that that contains a dependency function $w$ and an ordering of program points over $w$, as $(w,\sqsubseteq_w)$.

\begin{definition}[Partial order]
	Let $\psi\in\Psi$ be a pair of a dependency function $w$ and a relation of program points $\sqsubseteq_w$.
	We say that $\psi$ is partial order if $\sqsubseteq_w$ is a partial order.
\end{definition}
\fi

\begin{definition}[Greatest binding]\label{def:GBind}
	Let $u$ be an element, either a variable or location, and $S$ be a set of occurrences, then $uf(u,S)$ is given by:
	$$uf(u,S)=\inf\{u^p\in S\mid u^q\in S.q\sqsubseteq p\}$$
\end{definition}

Based on \cref{def:GBind}, we can present an instantiation of the function for the order $\sqsubseteq_w$:

\begin{definition}[]
	Let $w$ be a dependency function, $\sqsubseteq_w$ be an order for $w$, $u$ be an element, either a variable or location, and $S$ be a set of occurrences, then $uf_{\sqsubseteq_w}$ is given by:
	$$uf_{\sqsubseteq_w}(u,w)=\inf\{u^p\in dom(w)\mid u^q\in dom(w.q\sqsubseteq_w p\}$$
\end{definition}


\iffalse
In the semantics, which we present in \cref{sec:sem}, we need to lookup the dependencies of variables and locations.
This lookup is always for the greatest lower-bound of a variable or location, i.e., the newest bound variable, which is defined as:

\begin{definition}[$inf$ function]
	Let $\psi\in\Psi$ be a partial order, where $\psi=(w,\sqsubseteq_w)$, then the greatest lower-bound function for an element, $u\in\cat{Loc}\cup\cat{Var}$, is as follows:
	$$inf_\psi(u)=p$$
	iff
	$$p=\inf\{p'\in dom(w)\mid x^{q'}\in dom(w). q'\sqsubseteq_w p'\}$$
\end{definition}
\fi

\subsection{Collection semantics}\label{sec:sem}
We will now introduce the big-step semantics for our language and highlight some interesting transition rules.
In the big-step semantics, the transitions are of the from:
\begin{align*}
env\vdash\left\langle e^{p'},sto,\psi,p\right\rangle\rightarrow\left\langle v,sto',\psi',(L,V),p''\right\rangle
\end{align*}
Where $env\in\cat{Env}$, $sto\in\cat{Sto}$, and $\psi,\;\psi'\in\Psi$.
This should be read as, given the store $sto$, the pair $\psi$, and the previous program point $p$, the occurrence $e^{p'}$ evaluates to a value $v$, an updated store $sto'$, an updated pair $\psi'$, the dependency pair $(L,V)$, and the program point $p''$ reached after evaluating $e^{p'}$, given the bindings in the environment $env$.

The transition system is given by:
$$((\cat{Term}\cup\cat{Values})\times\cat{Store}\times\cat{W}\times\cat{P},\rightarrow,\cat{Values}\cat{Store}\times\Psi\times\Pow{\cat{Loc}^P\times\cat{Var}^P}\times\cat{P})$$
A highlight of the rules for $\rightarrow$ can be found in \cref{fig:ColSem}, the rest can be found in \cref{App:ColSem}.

\todo[inline]{Need to fix/rewrite for locations, since the description (and rule shown above) is old}
\begin{description}
	\item[\runa{Const}] is the simplest rule, as it has no premises and does not have any side effects.
		As constants are evaluated to the constant value, no dependencies are used, i.e., no variable or location occurrences are used to evaluate a constant.

	\item[\runa{Var}] This rule uses the environment and dependency function to get the value for a variable $x$ and its dependencies.
		Here, the $inf$ function is used, to get the greatest lower-bound of a variable in respect to the ordering $\sqsubseteq_w$ relation.
		Since we used to variable, we add it to the set of variable occurrences in the dependency pair, we got from the lookup in $w$.

	\item[\runa{Let}] creates a local binding that can be used later on.
		This rule extends both the environment and the pair $\psi$ by the value of evaluating $e_1^{p_1}$ and its dependencies.
		Here, we make a local binding for the variable in $e_2^{p_2}$, while the extension of $\psi$ is thus known for the rest of the program, since $\psi$ is a global collection of dependencies.

	\item[\runa{Loc-new}] creates a new reference, binds it to the value of $e^{p'}$, in the store, and extends the dependency function $w$.
		As references are considered global, and has no alias when created, the value of \runa{Loc-new} is a location.

	\item[\runa{Loc-read}] The \runa{Loc-read} rule expects that $e^{p'}$ is evaluated to a location $\loc$, and then lookup the value of $\loc$ in the store.
		Since the dependencies 

	\item[\runa{Loc-write}] rule updates the store with a new binding and updates the dependency function with the new dependencies.
		The extension is done to a new program points, which is not already used in the program, and the extension to the dependency function, we also adds the greatest lower-bound of $\loc$, in $w'$.
		Similarly to the \runa{Var} rule, we add the newly created location occurrence to $L'$, in the extension of $w''$.
\end{description}

\begin{figure}[H]
	\setlength\tabcolsep{8pt}
	\begin{tabular}{l}
		\runa{Const}\\[0.2cm]
			\inference[]{}
				{env\vdash \left\langle c^{p'},sto,\psi,p \right\rangle \rightarrow \left\langle c,sto,\psi,(\emptyset,\emptyset),p' \right\rangle}\\[1cm]
			
		\runa{Var}\\[0.2cm]
			\inference[]{}
			{env\vdash \left\langle x^{p'},sto,\psi,p \right\rangle \rightarrow \left\langle v,sto,\psi,(L,V\cup\{x^{p'}\}),p' \right\rangle}\\[0.4cm]
				Where $env(x)=v$, $\psi=(w,\sqsubseteq_w)$, $p''=\inf_\psi (x)$, and $w(x^{p''})=(L,V)$\\[1cm]

		\runa{Let}\\[0.2cm]
			\inference[]
			{env\vdash \left\langle e_1^{p_1},sto,\phi,p \right\rangle \rightarrow \left\langle v_1,sto_1,\phi_1,(L_1,V_1),p_1 \right\rangle &\\
			env[x\mapsto v_1]\vdash \left\langle e_2^{p_2},sto_1,\phi_2,p_1 \right\rangle \rightarrow \left\langle v,sto',\phi',(L,V),p_2 \right\rangle}
			{env\vdash \left\langle \left[\mbox{let}\;x\;e_1^{p_1}\;e_2^{p_2}\right]^{p'},sto,\phi,p \right\rangle \rightarrow \left\langle v,sto',\phi',(L,V),p' \right\rangle}\\[0.4cm]
		Where $\phi_1=(w_1,\sqsubseteq_w^1)$, $\phi_2=(w_1[x^{p_1}\mapsto(L,V)],\sqsubseteq_w^1)$\\[1cm]

		\runa{Ref}\\[0.2cm]
			\inference[]
				{env \vdash \left\langle e^{p'},sto,w,p \right\rangle \rightarrow \left\langle v,sto',w',(L,V),p' \right\rangle}
				{env\vdash \left\langle [\mbox{ref}\;e^{p'}]^{p''},sto,w,p \right\rangle \rightarrow \left\langle \loc,sto''[\loc\mapsto v],w'',(\emptyset,\emptyset),p'' \right\rangle}\\[0.4cm]
			Where $\loc = next$, $sto''=sto'[next\mapsto new\;\loc]$ and $w''=w'[\loc^{p''}\mapsto (L,V)]$\\[1cm]

		\runa{Ref-read}\\[0.2cm]
			\inference[]
				{env \vdash \left\langle e^{p'},sto,w,p \right\rangle \rightarrow \left\langle \loc,sto',w',(L,V),p' \right\rangle}
				{env\vdash \left\langle \left[!e^{p'}\right]^{p''},sto,w,p \right\rangle \rightarrow \left\langle v,sto',w',(L\cup\{\loc^{p''}\},V),p'' \right\rangle}\\[0.4cm]
			Where $sto'(\loc)=v$\\[1cm]


		\InfName{Ref-write}\\[0.2cm]
			\inference[]
				{env \vdash \left\langle e_1^{p'},sto,w,p \right\rangle \rightarrow \left\langle \loc,sto',w',(L,V),p' \right\rangle &\\
				env \vdash \left\langle e_2^{p''},sto',w',p' \right\rangle \rightarrow \left\langle v,sto'',w'',(L',V'),p'' \right\rangle}
				{env\vdash \left\langle \left[e_1^{p'}:=e_2^{p''}\right]^{p_3},sto,w,p \right\rangle \rightarrow \left\langle (),sto_3,w_3,(L,V),p_3 \right\rangle}\\[0.4cm]
				Where $sto_3=sto''[\loc\mapsto v]$, $p_2$ is fresh, $p_4=inf_{p''}(\loc,w')$\\
				$w_3=w''[\loc^{p_2}\mapsto(L'\cup\{\loc^{p_4}\},V')]$
	\end{tabular}
	\caption{Collection semantics}
	\label{fig:ColSem}
\end{figure}

Next, we will present some examples that illustrates how the dependency function is used to model parts of the data-flow in the semantics.

\begin{example}[Data-flow for abstractions]\label{ex:DFAbs}
The following program creates a local binding to the identity function and applies it twice.

\begin{lstlisting}[language=Caml, mathescape=true]
(let x ($\lambda$ y.(y$^1$))$^2$ (let z (x$^3$ 1$^4$)$^5$ (x$^6$ 2$^7$)$^{8}$)$^{9}$)$^{10}$
\end{lstlisting}
The transition tree can be found in \cref{FigEx.Abs}.
In the transition tree, we see that $\psi$ is extended a couple of times, where we will take a look at a couple of interesting extensions to $\psi$
The first time we evaluate the abstraction body, $\psi$ is on the following form:

$$\psi_2=(w_2=[x^{2}\mapsto(\emptyset,\emptyset), y^{4}\mapsto(\emptyset,\emptyset)],\sqsubseteq_w^2=\emptyset)$$
Here, the lookup of the parameter $y$ is simple, as there are only one occurrence, where we then know that $inf_{\psi_2}(y)=4$.

The second time we evaluate the body of the abstraction, $\psi$ is on the following form:

$$\psi_3=(w_3=[x^{2}\mapsto(\emptyset,\emptyset), y^{4}\mapsto(\emptyset,\emptyset), y^{7}\mapsto(\emptyset,\emptyset)],\sqsubseteq_w^2=\{4,7\})$$
Here, we now have two bindings for the parameter $y$, but since we also know that there are an ordering for the two occurrences of $y$, we then know that the program point $7$ is evaluated after $4$, as such we know that $inf_{\psi_3}(y)=7$.
\end{example}

\begin{landscape}
\subfile{../examples/DFAbs.tex}
\end{landscape}
\end{document}
