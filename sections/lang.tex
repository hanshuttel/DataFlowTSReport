\documentclass[../../master.tex]{subfiles}
\begin{document}
\section{Language}\label{sec:lang}
In this section, we will now present a functional subset of ReScript, based on the OCaml family.
The language introduced, contains the typical lambda expressions, bindings, pattern matching, and mutability.
For the purpose of the type system that will be presented later, we also extends to language with program points, such that each expression has its own unique program point, which we call syntactic occurrences.

The occurrences is used in the type system to analyse and distinguish between expressions, where there is syntactical occurrences, that is expressions, and semantical occurrences, those are variables and locations.

\subsection{Abstract syntax}
In this section we will introduce the abstract syntax, based on (previous paper), with some notable changes.
We reintroduce the syntactical categories as the previous paper, that is, $\Con$ denotes the category of constants, $\Val$ denotes the category of values, and $\Exp$ denotes the category of expressions.
Where $e, \; m \in \Exp$ and $c \in \Con$.

The syntactic categories for variables is changed, where we now have $\Var$ denotes the category for placeholder variables, that is variables from $\lambda$-abstractions, and $\IVar$ denotes the category for imperative variables, variables from binding expressions.
The syntactic category $\Loc$ denotes the category for locations, and $\Point$ that denotes the category for program point labels.
We then have $x,\;f\in(\Var\cup\IVar)$, $\loc\in\Loc$, and $p,\;p',\;p'',p_1,\cdots,p_n\in\Point$.

The formation rules is then defined, in \cref{fig:coresyntax}:

\begin{figure}[H]
	\begin{minipage}[t]{0.45\textwidth}
		\setlength\tabcolsep{4pt}
		\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
			term \; t &::= &e^p \\\\

			expression \; e &::= &x \mid c \mid t_1\;t_2 \mid \lambda x.t\\
			&| &\mbox{let} \; x \; t_1 \; t_2 \\
			&| &\mbox{let rec} \; x \; t_1 \; t_2 \\
			&| &\mbox{case} \; t_1 \; \{\pi\} \\
			&| &\mbox{ref} \; t \mid t_1 := t_2 \mid \; !t\\\\

			Patterns \; \pi &::= &(s\;t)\mid(s\;t)\;\pi\\\\

			Pattern \; s &::= &n \mid b \mid x \mid \_ \\
		\end{tabular}
	\end{minipage}
	\begin{minipage}[t]{0.45\textwidth}
		\setlength\tabcolsep{4pt}
		\begin{tabular}{>{$}l<{$}>{$}r<{$}>{$}l<{$}}
			Constant\; c &::= &n \mid b\\
			&| &PLUS \\
			&| &MINUS \\
			&| &TIMES\\
			&| &TIMES \\
			&| &EQUAL \\
			&| &LESS\\
			&| &GREATER\\
			&| &NOT \\ \\
		\end{tabular}
	\end{minipage}
	\caption{Abstract syntax}
	\label{fig:coresyntax}
\end{figure}

Most of these formation rules are similar to (previous paper) there are, however, some changes made in regards to how pattern matching is presented.
Some of the notable constructs is further explained below.

\paragraph{Constants}
The constants is either natural numbers $n$, boolean values $b$, or functional constants.
For each functional constant we introduce a function $apply$, that for each constant returns the result of applying a constant to its arguments.
Note that, for functional constant that take two or more arguments, $apply$ should be used twice, such that, as an example for $PLUS$ we have:
$$apply(apply(PLUS,2),2)=2+2$$

\paragraph{Abstractions}
$\lambda$-abstractions denotes functions with a parameter $x$ and body $t$, where $x\in\Var$.
Here, abstractions use juxtaposition of expressions, where abstractions have exactly one argument.

\paragraph{bindings}
Bindings are immutable and is done through local declaration, which can be recursive or non-recursive by the use of the $rec$ keyword.
A binding is done on placeholder variables, such that $x,\;f\in\IVar$.
Here, if $\mbox{let}\;x\;t_1\;t_2$ has an occurrence of $x$ in $t_1$ it is not treated as a recursive call to $x$ and $x$ should thus be specified elsewhere.
If we add the $rec$ keyword, then if $x$ appears in $t_1$, it should thus be treated as a recursive call to $x$.

\paragraph{Mutability}
The mutability is handled as references, that is, for the constructs $\mbox{ref}\;t$, $t_1\;:=\;t_2$, and $!t$, for declaring a new location, writing to a location, or reading from a location, respectively.
These constructs wraps the mutability to a semantical construct for locations, which are handled on runtime.
Note that, even though bindings are immutable, a variable can still be bound to a location.
This does not make the variable mutable, as it will then be bound to this location, and cannot be bound to another value or location.

\paragraph{Pattern matching}
The pattern matching construct matches a term $t$ with the pattern bindings in $\pi$.
The pattern matching is done by matching on each pattern, until a match is found, in the order given by the syntax.
A pattern binding is of the form $(s\;t)$, with at least one pattern binding.
We also denote $|\pi|$ as the number of pattern bindings.

\subsection{Semantics}\label{sec:sem}
We will now introduce the big-step semantics extended with the collection of occurrence dependencies.
The collection of occurrence dependencies is done through the dependency function $w$, defined as:
$$w:\Var^P\cup\IVar^P\cup\Loc^P\rightharpoonup\Pow{\Loc^P\times\Var^P\cup\IVar^P}$$
where a lookup in the function would look like $w(x^p)=(L,V)$, where $L=\{\loc^{p_1},\cdots,\loc^{p_n}\}$ and $V=\{x_1^{p'_1},\cdots,x_y^{p'_y}\}$ is the set of location occurrences and variables occurrences, respectively.

With the dependency function defined, we can now present the transition system, which is similarly defined in (previous paper), and are of the form $env\vdash\left\langle e^{p'},sto,w,p\right\rangle\rightarrow\left\langle v,sto',w',(L,V),p''\right\rangle$, where $env\in\Env$ and $sto\in\Sto$.
This should be read as, given the store $sto$, dependency function $w$, and the previous program point $p$, the syntactical occurrence $e^{p'}$ evaluates to a value $v$, an updated store $sto'$, an updated dependency function $w'$, the liveness pair $(L,V)$, and the program point $p''$ reached after evaluating $e^{p'}$, given the bindings in the environment $env$.

The environment keeps the bindings currently known, such that:
$$\Env=\Var\cup\IVar\rightharpoonup\Val$$

The store keeps the location bindings known and a placeholder $next$ that represent the next free location.

$$\Sto=\Loc\cup\{next\}\rightharpoonup\Val$$

Where $\Val$ is similarly defined, as in (previous paper):
\begin{itemize}
	\item All constants are values.
	\item Locations are values.
	\item Closures, \InfVal{x,e,env} are values.
	\item Recursive closures, \InfVal{f,x,e,env}, are values.
	\item Unit values, $()$, are values.
\end{itemize}
In other words, we have
\begin{align*}
	&\Val=\Con\cup\Loc\cup(\Var\cup\IVar)\times\Exp\times\Val\cup\\
	&(\Var\cup\IVar)\times(\Var\cup\IVar)\times\Exp\times\Val\cup()
\end{align*}

We, similarly to (prev paper), assume the existence of a function $new:\Loc\rightharpoonup\Loc$, which takes a location and finds the next location.
This function is only used on the $next$ location placeholder to find the next free location, i.e. a location that is not already bound in $sto$.

Note that, in the semantics we refer to syntactical occurrences, $e^p$, directly instead of terms.
This is done, as will be obvious later, to directly refer to program points.
\bigskip

Only a couple of interesting transition rules will be shown here, the rest can be found in \cref{App:ColSem}.
The first transition rule, $\runa{Con}$, is the simplest rule that shows part of the transition system.
Here, as a constant is directly evaluated there is no side effects, the pair $(L,V)$ is empty, and the program point reached after evaluating $c^p$ is $p$.

\todo[inline]{$\runa{Var}$ description needs a rewrite}
In the second rule, $\runa{Var}$, the environment and dependency function comes into play, as the value and dependencies of the variable needs to be looked up.
The value for the variable is easy, as it is directly looked up in the environment.
To get the dependencies of a variable, the closest occurrence needs to be found first.
This is done through the $inf_p$ function, which finds the closest occurrence for the same variable in $w$, and returns the program point.
With the given program point, the dependencies for this variable, at the given program point, can be looked up in $w$.
Since the variable occurrence, $x^{p'}$, is used, it is added to the set of variable occurrences.

The third rule, $\runa{let}$, is for when a local declaration is reached, here we add the information from the local declaration in both the environment and dependency function.
The dependency function is updated with the liveness pair from evaluating the local declaration for the variable occurrence $x^{p'}$, where the program point is the point reached after evaluating the local declaration.

The next two rules shown, $\runa{Loc new}$ and $\runa{Loc write}$, are for handling creating a new reference and writing to a reference.
The $\runa{Loc new}$ rule evaluated the body to a value $v$ and returns a location.
This location, $\loc$, is retrieved from the placeholder location $next$ in $sto$ and $\loc$ is bound to $v$ in $sto$.
The dependency function is also updated with the liveness information from evaluating the body, and is bound to the occurrence for $\loc$ at the program point $p''$.

For $\runa{Loc write}$, first the two terms are evaluated, where first term needs to be a location.
The location $\loc$ is bound to the value from evaluating the second term, in $sto$ and the $w$ is updated with the liveness pair from the second term, to the occurrence for $\loc$ at point $p_3$.
Since the value of a write expression, in ReScript, does not return a value, the value returned here is the unit value $()$.


\begin{figure}[H]
	\setlength\tabcolsep{8pt}
	\begin{tabular}{l}
		\InfName{Const}\\[0.2cm]
			\inference[]{}
				{env\vdash \left\langle c^{p'},sto,w,p \right\rangle \rightarrow \left\langle c,sto,w,(\emptyset,\emptyset),p' \right\rangle}\\[1cm]
			
		\InfName{Var}\\[0.2cm]
			\inference[]{}
				{env\vdash \left\langle x^{p'},sto,w,p \right\rangle \rightarrow \left\langle v,sto,w,(L,V\cup\{x^{p'}\}),p' \right\rangle}\\
				Where $env(x)=v$, $p''=\inf_{p} (x^{p'},w)$, and $w(x^{p''})=(L,V)$\\[1cm]

		\InfName{Let}\\[0.2cm]
			\inference[]
			{env\vdash \left\langle e_1^{p'},sto,w,p \right\rangle \rightarrow \left\langle v,sto',w',(L,V),p' \right\rangle &\\
			env[x\mapsto v]\vdash \left\langle e_2^{p''},sto',w'',p' \right\rangle \rightarrow \left\langle v',sto'',w_3,(L',V'),p'' \right\rangle}
			{env\vdash \left\langle [\mbox{let}\;x\;e_1^{p'}\;e_2^{p''}]^{p_3},sto,w,p \right\rangle \rightarrow \left\langle v',sto'',w_3,(L',V'),p_3 \right\rangle}\\
		Where $w''=w'[x^{p'}\mapsto(L,V)]$\\[1cm]

		\InfName{Loc\;new}\\[0.2cm]
			\inference[]
				{env \vdash \left\langle e^{p'},sto,w,p \right\rangle \rightarrow \left\langle v,sto',w',(L,V),p' \right\rangle}
				{env\vdash \left\langle [\mbox{ref}\;e^{p'}]^{p''},sto,w,p \right\rangle \rightarrow \left\langle \loc,sto''[\loc\mapsto v],w'',(L,V),p'' \right\rangle}\\
			Where $\loc = next$, $sto''=sto'[next\mapsto new\;\loc]$ and $w''=w'[\loc^{p''}\mapsto (L,V)]$\\[1cm]


		\InfName{Loc\;write}\\[0.2cm]
			\inference[]
				{env \vdash \left\langle e_1^{p'},sto,w,p \right\rangle \rightarrow \left\langle \loc,sto',w',(L,V),p' \right\rangle &\\
				env \vdash \left\langle e_2^{p''},sto',w',p' \right\rangle \rightarrow \left\langle v,sto'',w'',(L',V'),p'' \right\rangle}
				{env\vdash \left\langle [e_1^{p'}:=e_2^{p''}]^{p_3},sto,w,p \right\rangle \rightarrow \left\langle (),sto_3,w_3,(L,V),p_3 \right\rangle}\\
				Where $sto_3=sto''[\loc\mapsto v]$ and $w_3=w''[\loc^{p_3}\mapsto(L',V')]$\\[1cm]
	\end{tabular}
	\caption{Collection semantic}
	\label{fig:ColSem}
\end{figure}
\end{document}
