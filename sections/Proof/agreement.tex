\documentclass[../../master.tex]{subfiles}
\begin{document}
\subsection{Agreement}
This section introduces the agreement between the type system and the semantics, where we will present the relation between the binding models in the type system and semantics, and show the relation between the types and the semantics.

We will first introduce the agreement between the binding models between the type system and semantics, i.e., show how the type environment and approximated order of program points relate to the environment, store, and dependency function.
Then we will show the type agreement, that is, show that what conditions there are for a type to agree with the semantics.
The type agreement needs to show when the dependencies agrees and for alias information.
\bigskip

The first agreement we present is the environment agreement, which ensures that that the type environment and approximated order of program points are a good approximation of the binding model in the type system, that is, for the environment $env$, store $sto$, dependency function $w$, and the relation of program points over $w$.

Here $env$, $sto$, and $w$ contains information for en evaluation in the semantics, either before or after an evaluation.
The type environment $\Gamma$ contains the local information for variable bindings and global information for internal variables, and the approximated order of program points $\Pi$ is an approximation of all program points in an occurrence.

For these to agree, we relate them only to the information currently known in $env$, $sto$, and $w$, where for local information, the variables in $env$, then there is also an occurrence for that variable in $w$ and $\Gamma$.
This ensures that every bound variable also exists in $w$ and $\Gamma$.
Furthermore, we also ensures that the local declarations $x$ know by $env$, the dependencies of all occurrences for $x$ in $w$ and type in $\Gamma$ agrees, as defined in \cref{def:TAgree}.

We similarly handles the agreement for global information, between $sto$, $w$ and $\Gamma$.
Here we need to make sure that all currently known locations, then there exists an appropriate internal variable that represent that location.
As we are denoting a location and the internal variable that represent this with the same program points, we always compare them by program points.
We also make sure that the dependencies of all those locations also agrees with the type of the internal variable the represents them.

Lastly, we also need to make sure that $\Pi$ is a good approximation of the information know in $w$, denoted as $\sqsubseteq_w$, and the order of programs points on $w$.
The first condition for this is that, if an order is defined in $\sqsubseteq_w$, then $\Pi$ also agrees on this order.
As for the second condition, since $\Pi$ is an approximation of an occurrence, and as such also approximates for all paths (the different branches from pattern matching), and $\Gamma$ contains all bindings for an internal variable in an occurrence.
We then need to make sure that for all locations, $\loc$, currently known, then there exists a program point $p'$, such that by finding the greatest binding for $\loc$ currently known in $w$, 
this occurrence also exists when finding all greatest binding for the set of $p$-chains $\Upsilon_{p'}$.

\begin{definition}[Environment agreement]\label{def:EnvAgree}
	Let $(w,\sqsubseteq_w)$ be a pair containing the dependency function and a relation over it, $env$ be an environment, $sto$ be the a store, $\Gamma$ be a type environment, and $\Pi$ be an approximated program point order.
	We say that:
	$$(env,sto,(w,\sqsubseteq_w))\models(\Gamma,\Pi)$$
	if 
	\begin{enumerate}
		\item $\forall x\in dom(env).(\exists x^p\in dom(w))\wedge(x^p\in dom(w)\Rightarrow \exists x^p\in dom(\Gamma))$
		\item $\forall x^p\in dom(w).x^p\in dom(\Gamma)\Rightarrow w(x^p)=(L,V)\wedge\Gamma(x^p)=T.(w,env,(L,V))\models T$
		\item $\forall \loc\in dom(sto).(\exists \loc^p\in dom(w))\wedge(\exists \nu x.\forall p\in\{p'\mid\loc^{p'}\in dom(w)\}\Rightarrow\nu x^p\in dom(\Gamma))$
		\item $\forall \loc^p \in dom(w).\exists\nu x^{p}\in dom(\Gamma)\Rightarrow w(\loc^p)=(L,V)\wedge\Gamma(\nu x^{p})=T.(w,env,(L,V))\models T$
		\item if $p_1\sqsubseteq_w p_2$ then $p_1\sqsubseteq_\Pi p_2$
	\item $\forall \loc^p\in dom(w).\exists \nu x^p\in dom(\Gamma}\Rightarrow\exists p'\in\cat{P}.uf_{\sqsubseteq_w}(\loc,w)\in uf_{\Upsilon_{p'}}(\nu x,\Gamma)$
	\end{enumerate}
\end{definition}

In \cref{def:EnvAgree}, the agreement contains a lot of conditions, but in essence it states:
\begin{description}
	\item[variables] If a variable exists in $env$, then there exists an occurrence of that variable in both $w$ and $\Gamma$.
		And for all variable occurrences, $x^p$, that both $w$ and $\Gamma$ knows about, the dependency and type for $x^p$ agrees.
	\item[locations] The agreement is similar for locations, but there is an extra step as the type system represents locations as internal variables.
		The comparison is thus done by comparing program points and since this is global, the comparison is done for all program points that exists for a a location $\loc$ in $w$.
\end{description}

\todo[inline]{Explain why $T_1$ is not used in the type agreement}
\begin{definition}[Type agreement]\label{def:TAgree}
	Let $env$ be an environment, $\psi$ be a pair, $(L,V)$ be a dependency pair, and $T$ be a type.
	We say that:
	$$(env,(w,\sqsubseteq_w),v,(L,V))\models(\Gamma,T)$$
	iff
	\begin{itemize}
		\item $v\neq\loc$ and $T=T_1\rightarrow T_2$:
		\begin{itemize}
			\item $(env,(w,\sqsubseteq_w),v,(L,V))\models(\Gamma,T_2)$
		\end{itemize}

		\item $v\neq\loc$ and $T=(\delta,\kappa)$:
		\begin{itemize}
			\item $(env,(L,V))\models\delta$
		\end{itemize}

		\item $v=\loc$ then $T=(\delta,\kappa)$ where:
		\begin{itemize}
			\item $(env,(L,V))\models\delta$
			\item $(env,(w,\sqsubseteq_w),v)\models(\Gamma,\kappa)$
		\end{itemize}
	\end{itemize}
\end{definition}

\begin{definition}[Dependency agreement]\label{def:DepAgree}
	Let $env$ be an environment, $(L,V)$ be a dependency pair, and $\delta$ be a set of variables.
	We say that:
	$$(env,(L,V))\models\delta$$
	if
	\begin{itemize}
		\item $V\subseteq\delta$,
		\item For all $\loc^p\in L$ where $\exists x\in dom(env).env(x)=\loc$, we then have $\{x\in dom(env)\mid env(x)=\loc\}\subseteq \kappa_i^0$ for a $\kappa_i^0\in\delta$
		\item For all $\loc^p\in L$ where $\not\exists x \in dom(env).env(x)=\loc$ then there exists a $\kappa_i^0\in\delta$ such that $\kappa_i^0\subseteq\cat{IVar}$
	\end{itemize}
\end{definition}

\begin{definition}[Alias agreement]\label{def:AliasAgree}
	Let $env$ be an environment, $(w,\sqsubseteq_w)$ be a pair of a dependency function and a relation over $w$, $\loc$ be a location, and $\kappa$ be an alias set.
	We say that:
	$$(env,(w,\sqsubseteq_w),\loc)\models(\Gamma,\kappa)$$
	if
	\begin{itemize}
		\item $\exists \loc^p\in dom(w).\nu x^p\in dom(\Gamma)\Rightarrow\nu x\in\kappa$
		\item $env^{-1}(\loc)\neq\emptyset.\exists \kappa^0_i\in\kappa^0\Rightarrow
			(env^{-1}(\loc)\subseteq\kappa^0_i)\wedge(\exists \loc^p\in dom(w).\nu x^p\in dom(\Gamma)\Rightarrow\nu x\in\kappa^0_i)$
		\item $env^{-1}(\loc)=\emptyset.\exists \kappa^0_i\in\kappa^0\Rightarrow
			(\kappa^0_i\subseteq\cat{IVar})\wedge(\exists \loc^p\in dom(w).\nu x^p\in dom(\Gamma)\Rightarrow\nu x\in\kappa^0_i)$
		%\item $\forall\loc^p\in dom(w).(env^{-1}(\loc)\cap\cat{Var}\neq\emptyset)\Rightarrow(\exists \kappa^0_i\in\kappa.\exists\nu x^p\in dom(\Gamma).\nu x\in\kappa^0_i\wedge env^{-1}(\loc)\subseteq\kappa^0_i)$
		%\item $\forall\loc^p\in dom(w).(env^{-1}(\loc)\subseteq\cat{IVar})\Rightarrow(\exists \kappa^0_i\in\kappa.\exists\nu x^p\in dom(\Gamma).\nu x\in env^{-1}(\loc)\subseteq\kappa^0_i)$
	\end{itemize}
\end{definition}
\end{document}
