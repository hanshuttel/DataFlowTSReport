\documentclass[../../master.tex]{subfiles}
\begin{document}
\section{Soundness}
In this section we present the soundness of the liveness system with respect to the collection semantics, shown in \cref{App:ColSem}.
The liveness system is sound, if the liveness type contains at least all live occurrences at a given program point.
The liveness system is sound in respect to the collection semantics, that is, the liveness type is an overapproximation of the occurrences in the collection semantics.

The liveness system depends on three global bases, one for variable occurrences, for abstract locations, and for an approximation of program points.
To show that these bases are good, we need to define when they agree with the semantics, i.e., to show that the bases overapproximate the dependency function, and that the approximated order of program points is a good approximation.

\subsection{Agreement}
\todo[inline]{This section talks about the relation between the semantics and type system}
\todo[inline]{$env,sto,w$ is a model of $\Gamma$}
The first agreement we present here is the agreement for the type environment $\Gamma$ and dependency function $w$.
The $\Gamma$ contains both local dependencies for variable occurrences and global dependencies for internal variable occurrences, while $w$ contains global dependencies for variable and location occurrences.

As such. it is clear that $\Gamma$ is not a direct model of $w$, but models the current state that is evaluated, thus it models both the environment, store, and dependency function.
This is clear, as both the environment and type environment both only contains local information for variables.

On the other hand, locations are treated as global information in the type system, which are represented as internal variables, as such if a location exists in the store it would thus the equivalent would exists in the type environment.
Since the type environment contains only occurrences, locations and internal variables can thus be compared by program points, as locations and internal variables are created and updated at the same program points.
This relation is done by comparing between between the store, dependency function and type environment.

Lastly, since the dependency function and type environment collects information about dependencies, the dependencies ar then compared.
Since there a both local and global information, and the dependency function collects all information globally, the dependency comparison is done only on the the information  for occurrences that exists in the domain of both $w$ and $\Gamma$.

\begin{definition}[Environment agreement]\label{def:EnvAgree}
	Let $w$ be a dependency function, $env$ be an environment, $sto$ be the a store, $\Gamma$ be a type environment, and $\Pi$ be an approximated program point order.
	We say that:
	$$(env,sto,w)\models(\Gamma,\Pi)$$
	if 
	\todo[inline]{Combine 1 and 2, and combine the 4 and 5}
	\begin{itemize}
		\item $\forall x\in dom(env).(\exists x^p\in dom(w))\wedge(x^p\in dom(w)\Rightarrow \exists x^p\in dom(\Gamma))$
		\item $\forall x^p\in dom(w).x^p\in dom(\Gamma)\Rightarrow w(x^p)=(L,V)\wedge\Gamma(x^p)=T.(w,env,(L,V))\models T$
		\item $\forall \loc\in dom(sto).(\exists \loc^p\in dom(w))\wedge(\exists \nu x.\forall p\in\{p'\mid\loc^{p'}\in dom(w)\}\Rightarrow\nu x^p\in dom(\Gamma))$
		\item $\forall \loc^p \in dom(w).\exists\nu x^{p}\in dom(\Gamma)\Rightarrow w(\loc^p)=(L,V)\wedge\Gamma(\nu x^{p})=T.(w,env,(L,V))\models T$
		\item if $p_1\sqsubseteq_w p_2$ then $p_1\sqsubseteq_\Pi p_2$
	\end{itemize}
\end{definition}

\begin{definition}[Environment agreement]\label{def:EnvAgree}
	Let $w$ be a dependency function, $env$ be an environment, $sto$ be the a store, and $\Gamma$ be a type environment.
	We say that:
	$$(env,sto,w)\models\Gamma$$
	if 
	\todo[inline]{Combine 1 and 2, and combine the 4 and 5}
	\begin{itemize}
		\item $\forall x\in dom(env)\Rightarrow\exists x^p\in dom(w)$
		\item $\forall x\in dom(env).x^p\in dom(w)\Rightarrow \exists x^p\in dom(\Gamma)$
		\item $\forall x^p\in dom(w).x^p\in dom(\Gamma)\Rightarrow w(x^p)=(L,V)\wedge\Gamma(x^p)=T.(w,env,(L,V))\models T$
		\item $\forall \loc\in dom(sto)\Rightarrow\exists \loc^p\in dom(w)$
		\item $\forall \loc\in dom(sto)\Rightarrow\exists \nu x.\forall p\in\{p'\mid\loc^{p'}\in dom(w)\}$ then $\nu x^p\in dom(\Gamma)$
		\item $\forall \loc^p \in dom(w).\exists\nu x^{p}\in dom(\Gamma)\Rightarrow w(\loc^p)=(L,V)\wedge\Gamma(\nu x^{p})=T.(w,env,(L,V))\models T$
	\end{itemize}
\end{definition}
In \cref{def:EnvAgree}, the agreement contains a lot of conditions, but in essence it states:
\begin{description}
	\item[variables] If a variable exists in $env$, then there exists an occurrence of that variable in both $w$ and $\Gamma$.
		And for all variable occurrences, $x^p$, that both $w$ and $\Gamma$ knows about, the dependency and type for $x^p$ agrees.
	\item[locations] The agreement is similar for locations, but there is an extra step as the type system represents locations as internal variables.
		The comparison is thus done by comparing program points and since this is global, the comparison is done for all program points that exists for a a location $\loc$ in $w$.
\end{description}

\begin{definition}[Type agreement]\label{def:TAgree}
	Let $w$ be a dependency function, $env$ be an environment, $(L,V)$ be a dependency pair, and $T$ be a type.
	We say that:
	$$(w,env,v,(L,V))\models(\Gamma,T)$$
	iff
	\begin{itemize}
		\item $v\neq\loc$ and $T=T_1\rightarrow T_2$:
		\begin{itemize}
			\item $(w,env,v,(L,V))\models(\Gamma,T_2)$
		\end{itemize}

		\item $v\neq\loc$ and $T=(\delta,\kappa)$:
		\begin{itemize}
			\item $(env,(L,V))\models\delta$
		\end{itemize}

		\item $v=\loc$ then $T=(\delta,\kappa)$ where:
		\begin{itemize}
			\item $(env,(L,V))\models\delta$
			\item $(w,env,v)\models(\Gamma,\kappa)$
		\end{itemize}
	\end{itemize}
\end{definition}

\begin{definition}[Dependency agreement]\label{def:DepAgree}
	Let $env$ be an environment, $(L,V)$ be a dependency pair, and $\delta$ be a set of variables.
	We say that:
	$$(env,(L,V))\models\delta$$
	if
	\begin{itemize}
		\item $V\subseteq\delta$,
		\item For all $\loc^p\in L$ where $\exists x\in dom(env).env(x)=\loc$, we then have $\{x\in dom(env)\mid env(x)=\loc\}\subseteq \kappa_i^0$ for a $\kappa_i^0\in\delta$
		\item For all $\loc^p\in L$ where $\not\exists x \in dom(env).env(x)=\loc$ then there exists a $\kappa_i^0\in\delta$ such that $\kappa_i^0\subseteq\cat{IVar}$
	\end{itemize}
\end{definition}

\begin{definition}[Alias agreement]\label{def:AliasAgree}
	Let $env$ be an environment, $\loc$ be a location, and $\kappa$ be an alias set.
	We say that:
	$$(env,w,\loc)\models(\Gamma,\kappa)$$
	if
	\begin{itemize}
		\item $\exists \loc^p\in dom(w).\nu x^p\in dom(\Gamma)\Rightarrow\nu x\in\kappa^0_i$
		\item $env^{-1}(\loc)\neq\emptyset$ then $\exists \kappa^0_i\in\kappa.(env^{-1}(\loc)\subseteq\kappa^0_1)\wedge(\exists \loc^p\in dom(w).\nu x^p\in dom(\Gamma)\Rightarrow\nu x\in\kappa^0_i)$
		\item $env^{-1}(\loc)=\emptyset$ then $\exists \kappa^0_i\in\kappa.(\kappa^0_i\subseteq\cat{IVar})\wedge(\exists \loc^p\in dom(w).\nu x^p\in dom(\Gamma)\Rightarrow\nu x\in\kappa^0_i)$
		%\item $\forall\loc^p\in dom(w).(env^{-1}(\loc)\cap\cat{Var}\neq\emptyset)\Rightarrow(\exists \kappa^0_i\in\kappa.\exists\nu x^p\in dom(\Gamma).\nu x\in\kappa^0_i\wedge env^{-1}(\loc)\subseteq\kappa^0_i)$
		%\item $\forall\loc^p\in dom(w).(env^{-1}(\loc)\subseteq\cat{IVar})\Rightarrow(\exists \kappa^0_i\in\kappa.\exists\nu x^p\in dom(\Gamma).\nu x\in env^{-1}(\loc)\subseteq\kappa^0_i)$
	\end{itemize}
\end{definition}

\begin{definition}[Environment judgement]
	Let $v_1,\cdots,v_n$ be values such that $\Gamma';\Pi\vdash v_i:T_i$, for $1\leq i\leq n$.
	Let $env$ be an environment where $env=[x_1\mapsto v_1,\cdots,x_n\mapsto v_n]$, $\Gamma$ be a type environment, and $\Pi$ be the approximated order of program points.
	We say that:
	$$\Gamma;\Pi\vdash env$$
	iff 
	\begin{itemize}
		\item For all $x_i\in dom(env)$ then $\exists x_i^p\in dom(\Gamma)$ where $\Gamma(x_i^p)=T_i$ then 
			$$\Gamma,\Pi\vdash env(x_i):T_i$$
	\end{itemize}
\end{definition}

\subsection{Type rules for values}
For the sake of proving the type system, we present type rules for values.
The formation rules for values can be given by:
$$v::=c\mid\loc\mid\left\langle x^{p},e^{p'},env\right\rangle\mid\left\langle x^{p},f^{p'},e^{p''},env\right\rangle\mid ()$$
Where the type rules is given in \cref{fig:ValTypeRules}.
\begin{figure}[H]
	\setlength\tabcolsep{8pt}
	\begin{tabular}{l}
		\hline\\
		\runa{Constant}\\[0.4cm]
			\inference[]{}
				{\Gamma;\Pi\vdash  c:(\emptyset, \emptyset)}\\[1cm]

		\runa{Location}\\[0.4cm]
			\inference[]{}
				{\Gamma;\Pi\vdash  \loc:(\delta, \kappa)}\\[1cm]

		\runa{Closure}\\[0.4cm]
			\inference[]
				{
					\Gamma;\Pi\vdash env \\
					\Gamma,x^{p}:T_1;\Pi\vdash e^{p'}:T_2
				}
				{\Gamma;\Pi\vdash \left\langle x^{p}, e^{p'}, env \right\rangle^{p''}:T_1\rightarrow T_2}\\[1cm]

		\runa{Recursive closure}\\[0.4cm]
			\inference[]
				{
					\Gamma;\Pi\vdash env \\
					\Gamma,x^{p}:T_1,f^{p'}:T_1\rightarrow T_2;\Pi\vdash e^{p''}:T_2
				}
				{\Gamma;\Pi\vdash \left\langle x^{p}, f^{p'}, e^{p''}, env \right\rangle^{p_3}:T_1\rightarrow T_2}\\[1cm]

		\runa{Unit}\\[0.4cm]
			\inference[]{}
			{\Gamma;\Pi\vdash  ():(\delta,\kappa)}\\[0.5cm]
		\hline
	\end{tabular}
	\caption{Type rules for values}
	\label{fig:ValTypeRules}
\end{figure}

\subsection{Lemma}
\begin{lemma}[History]\label{lemma:His}
	If 
	$$env\vdash\left\langle e^{p'},w,sto,p\right\rangle\rightarrow\left\langle v,w',sto',(L,V),p''\right\rangle$$
		and $x^{p_1}\in dom(w')\backslash dom(w)$ then $x^{p_1}\notin fv(e)$
\end{lemma}

\begin{lemma}[Strengthening]\label{lemma:Strength}
	If $\Gamma,x^{p'}:T';\Pi\vdash e^{p}:T$ and $x\notin fv(e^p)$, then $\Gamma;\Pi\vdash e^{p}:T$
\end{lemma}

%\subfile{agreement.tex}
%\subfile{valueTRules.tex}
\subfile{proof.tex}
\end{document}
