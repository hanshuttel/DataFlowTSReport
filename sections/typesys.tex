\documentclass[../../master.tex]{subfiles}
\begin{document}
\section{Type system for data-flow analysis}
This section will introduce the type system for the data-flow analysis on the language presented in \cref{sec:lang}.
The purpose of the type system presented here captures the notion of data-flow in in a program.
Here, we assign terms with the data used to evaluate the term.
Since the language introduces mutability, we also enable the analysis of aliases, for this we introduce the notion of internal variables, denoted as $\nu x,\; \nu y\in\cat{IVar}$, to represent the semantic notion of locations.
We also introduce the category of \cat{Id} to denote all variables and internal variables, such that $\cat{Id}=\cat{Var}\cup\cat{IVar}$.

\subsection{Types}
We denote the set of types as \cat{Types}, which are given by the following formation rules:

$$T::=(\delta,\kappa)\mid T_1 \rightarrow T_2$$

Here, we introduce two types, the base type $(\delta,\kappa)$ and the function type $T_1 \rightarrow T_2$.
The base type is a tuple containing $\delta$ and $\kappa$, where $\delta$ represents the set of occurrences used to evaluate a term and $\kappa$ represent the set of alias information for the value the term evaluates to.
As such, the idea is that if $\kappa$ is not empty then the value must evaluate to a location.
We also keep track of the minimum known aliases for a reference.
If, on the other hand, an expression has the function type then it represent hat the term represents an abstraction that takes an argument of type $T_1$ and returns a value of type $T_2$.

Since the type system approximates the data used for terms, we introduce two types of union.
The first union is a simple union that expects the types to be similar, that is, only the base types are allowed to be different.
\begin{definition}[Type union]
	Let $T_1$ and $T_2$ be two types, then the type union, $\cup$, are as follows:
	\begin{equation*}
		T_1\cup T_2=
		\left\{\begin{matrix}
			\mbox{If } \; T_1=(\delta,\kappa) \;\mbox{and}\; T_2=(\delta',\kappa')  & \mbox{then} \; (\delta\cup\delta',\kappa\cup\kappa')\\
			\mbox{else if } \; T_1=T_1'\rightarrow T_1''\;\mbox{and}\;T_2=T_2'\rightarrow T_2'' & \mbox{then} \; (T_1'\cup T_2')\rightarrow (T_1''\cup T_2'')
		\end{matrix}\right.
	\end{equation*}
\end{definition}

The second type union, is to add additional type information to an arbitrary type.
This type union is used to add an occurrence to a type, e.g., in the \runa{Var} rule where the variable occurrence needs to be added to the type of that variable.
\begin{definition}[Base type union]
	Let $T$ be an type and $(\delta,\kappa)$ be a base type, then the union of these are as follows:
	\begin{equation*}
		T\sqcup (\delta,\kappa)=
		\left\{\begin{matrix}
			\mbox{If } \; T=(\delta',\kappa')  & \mbox{then} \; (\delta\cup\delta',\kappa\cup\kappa')\\
			\mbox{else if } \; T=T_1\rightarrow T_2 & \mbox{then} \; T_1\rightarrow(T_2\sqcup (\delta,\kappa))
		\end{matrix}\right.
	\end{equation*}
\end{definition}

\subsection{Basis and type environment}
This section introduces the basis for the type checker, as such the type bases er assumptions.
\begin{definition}[Type Base for aliasing]
	For a program $p$, let $var\in\cat{Var}$ be a set of all variables in $p$ and $ivar\in\cat{IVar}$ be the set of all internal variables in $p$.
	The type base $\kappa^0=\{\kappa^0_1,\cdots,\kappa^0_n\}$ is then a partition of $var\cup ivar$, where $\kappa_i^0\cap\kappa_j^0=\emptyset$ for all $i\neq j$.
\end{definition}
The type base for aliasing is an assumption for which variables that shares the same internal variable, and as such, shares the same location.
As such, if we have a an assumption for a variable $x$, such that $\{x\}=\kappa_i$, then $x$ would not be an alias to a location.
On the otherhand if we have $\{y,\nu y\}=\kappa_j$, for a variable $y$ and internal variable $\nu y$, then $y$ is an alias for $\nu y$.
\bigskip

Next, we will introduce the type environment:
\begin{definition}[Type Environment]
	A type environment $\Gamma$ is a partial function $\Gamma:Id^P\rightharpoonup TYPES$
\end{definition}
As such, $\Gamma$ represents the types for variables and internal variables.

\begin{definition}[Approximated order of program points]
	An approximated order of program points $\Pi$, such that: 
	\begin{itemize}
		\item  $p\sqsubseteq p'\in\Pi$
		\item The order of program points is transitive, such that if $p\sqsubseteq p'\in\Pi$ and $p'\sqsubseteq p''\in\Pi$ then $p\sqsubseteq p''\in\Pi$.
	\end{itemize}
\end{definition}
The intuition behind an approximated order of program points is the execution order, and should as such follow all possible evaluation paths for a given program.

\begin{definition}[Lookup function]
	let $x$ be a variable, $p$ be a program point, $\Gamma$ be the type environment , and $\Pi$ be an approximated program order, then
	$$\Lambda(x^p, \Gamma, \Pi)=p'$$
	iff
	$$p'' = inf\{x^{p_1}\in dom(\Gamma)\mid x^{p_2}\in dom(\Gamma).p_2\sqsubseteq_\Pi p_1\}$$
\end{definition}

Since $\Pi$ is partial order, and possible not a total order, we define a split of $\Pi$:

\begin{definition}[splitting $\Upsilon$]
	Let $\Pi$ be a order of program points, we say that a subset of $\Pi$ is a total order $\Pi^{*}$ if all elements in $\Pi$ is related.
\end{definition}

\begin{definition}[splitting $\Upsilon$]
	let $\Upsilon$ be a set of all total order of $\Pi$, where
	\begin{itemize}
		\item if $\Pi^{*}_i\in\Upsilon.\not\exists \Pi^{*}\in\Pi\Rightarrow\Pi^{*}_i\subseteq\Pi^{*}$
	\end{itemize}
\end{definition}

We then define a function to get all greatest lower-bound program points $p$ from the splitting $\Upsilon$
\begin{definition}[Lookup function]
	let $x$ be a variable, $p$ be a program point, $\Gamma$ be the type environment , $\Upsilon$ be a splitting of $\Pi$, then
	$$\Lambda_\Upsilon(x^p, \Gamma, \Upsilon)=\bigcup_{\Pi^{'}\in\Upsilon}(\Lambda(x^p,\Gamma,\Pi^{*}))$$
	iff
	$$p'' = inf\{x^{p_1}\in dom(\Gamma)\mid x^{p_2}\in dom(\Gamma).p_2\sqsubseteq_\Pi p_1\}$$
\end{definition}

\iffalse
\subsection{Bases}
In the semantics, presented in \cref{sec:sem}, we keep track of dependencies through the dependency function $w$, value bindings through the environment, and location bindings through the store.

The occurrence dependency system similarly needs to keep track of dependencies.
In the system, we keep track of dependencies through the types instead of the liveness pair used in $w$.
We introduce the notion of a type dependency base $\Gamma$, that keeps track of the type of variables.

\begin{definition}[Type base]
	The type base $\Gamma$ is a partial function $\Gamma:Id^P\rightharpoonup TYPES$
\end{definition}

A lookup in the type base $\Gamma$ is of the form $\Gamma(x^p)=T$, for placeholder and imperative variables, and $\Gamma(\nu x^p)=T$, for internal variables.

\begin{definition}[Extending the type base]
	We write $\Gamma,x^p:T$ for the type base $\Gamma'$ defined by:
	\begin{align*}
		\Gamma'(y^{p'})=
		\left\{\begin{matrix}
			\Gamma(x^p) & \mbox{if}\;y^{p'} \neq x^{p}\\ 
			T & \mbox{if}\;y^{p'} = x^{p}
		\end{matrix}\right.
	\end{align*}
\end{definition}
The extension of $\Gamma$ for internal variables can be similarly defined.
\bigskip

The last base, $\Pi$, is the approximated order of program points, where we denote $p\sqsubseteq p'\in\Pi$, if $p$ is an earlier or the same program point as $p'$.
We also denote $p \sqsubset p'\in\Pi$ if $p$ is an earlier program point than $p'$.
The order of program points is also transitive, i.e., if $p\sqsubseteq p'\in\Pi$ and $p'\sqsubseteq p''\in\Pi$ then $p\sqsubseteq p''\in\Pi$.
\fi

\subsection{Judgement}
The type judgement is defined as:
$$\Gamma;\Pi\vdash e^p: T$$
And should be read as, the occurrence $e^p$ has type $T$, given the dependency bindings $\Gamma$ and the approximated order of program points $\Pi$.

\begin{definition}[$\Lambda$ function]
	Let $x^p\in \cat{Id}$, $\Gamma$ be the type base, and $\Pi$ be the approximated order of program points, the $\Lambda(x^p,\Gamma,\Pi)=x^{p'}$ is as follows
	\begin{align*}
		\Lambda(x^p,\Gamma,\Pi)=\forall x^{p''}\in dom(\Gamma). p''\sqsubset p\in\Pi\Rightarrow \exists x^{p'}\in dom(\Gamma).p''\sqsubset p\in\Pi\wedge p'\sqsubseteq p''\in\Pi
	\end{align*}
\end{definition}

%\begin{landscape}
%\subfile{../examples/index.tex}
%\end{landscape}

\end{document}
