\documentclass[../../master.tex]{subfiles}
\begin{document}
\section{Type system for data-flow analysis}
This section will introduce the type system for data-flow analysis on dependencies and aliasing, for the language presented in \cref{sec:lang}.
This type system describes the dependencies and aliasing used to evaluate a term.
The analysis is done on occurrences, and since the language also introduces mutability, which introduce the notion of locations, we introduce the notion of internal variables to represent locations.
Therefore we introduce the category \cat{IVar} for internal variables, where the elements of \cat{IVar} is denoted by as $\nu x,\nu y\in\cat{IVar}$.
We further denote the set of all variables as $Id=\cat{Var}\cup\cat{IVar}$.

\subsection{Types}
Similar to type systems, we denote the syntactic category for types as \cat{Types} and is ranged over by $T$
A subset of \cat{Types} is the set of base types, ranged over by the pair $(\delta,\kappa)$, where $\delta\subseteq Id^P$ is a set of variable occurrences and $\kappa\subseteq\AVar$ is a set of internal variables.

The composite type for abstractions, denoted as $T_1\rightarrow T_2$, is that of a function that takes a value of type $T_1$ as input and returns a value of type $T_2$.

The formation rules for types is thus given as:
$$T::=(\delta,\kappa)\mid T_1 \rightarrow T_2$$

In the occurrence dependency system we make use of type unions, either by unifying two types, or unifying a type and base type.
A type union of two types is defined as follows, and is used when approximating the types from each branch in a \runa{Case} expression.
\begin{definition}[Type union]
	Let $T_1$ and $T_2$ be two types, then the type union, $\cup$, are as follows:
	\begin{equation*}
		T_1\cup T_2=
		\left\{\begin{matrix}
			\mbox{If } \; T_1=(\delta,\kappa) \;\mbox{and}\; T_2=(\delta',\kappa')  & \mbox{then} \; (\delta\cup\delta',\kappa\cup\kappa')\\
			\mbox{else if } \; T_1=T_1'\rightarrow T_1''\;\mbox{and}\;T_2=T_2'\rightarrow T_2'' & \mbox{then} \; (T_1'\cup T_2')\rightarrow (T_1''\cup T_2'')
		\end{matrix}\right.
	\end{equation*}
\end{definition}

A type union of a type and base type is used in the \runa{Var}, \runa{Case}, \runa{Ref}, and \runa{Ref read} rules.
This type union is used to add an occurrence to a type, e.g., in the \runa{Var} rule where the variable occurrence needs to be added to the type for that variable.
\begin{definition}[Base type union]
	Let $T$ be an type and $(\delta,\kappa)$ be a base type, then the union of these are as follows:
	\begin{equation*}
		T\sqcup (\delta,\kappa)=
		\left\{\begin{matrix}
			\mbox{If } \; T=(\delta',\kappa')  & \mbox{then} \; (\delta\cup\delta',\kappa\cup\kappa')\\
			\mbox{else if } \; T=T_1\rightarrow T_2 & \mbox{then} \; T_1\rightarrow(T_2\sqcup (\delta,\kappa))
		\end{matrix}\right.
	\end{equation*}
\end{definition}

\subsection{Basis}
This section introduces the basis for the type checker, as such the type bases er assumptions.
\begin{definition}[Type Base for aliasing]
	For a program $p$, let $var\in\cat{Var}$ be a set of all variables in $p$ and $ivar\in\cat{IVar}$ be the set of all internal variables in $p$.
	The type base $\kappa^0=\{\kappa^0_1,\cdots,\kappa^0_n\}$ is a then partition of $var\cup ivar$, where $\kappa_i^0\cap\kappa_j^0=\emptyset$ for all $i\neq j$.
\end{definition}
The type base for aliasing is an assumption for which variables that shares the same internal variable, and as such, shares the same location.
As such, if we have a an assumption for a variable $x$, such that $\{x\}=\kappa_i$, then $x$ would not be an alias to a location.
On the otherhand if we have $\{y,\nu y\}=\kappa_j$, for a variable $y$ and internal variable $\nu y$, then $y$ is an alias for $\nu y$.

\subsection{Type environment}
\begin{definition}[Type Environment]
	A type environment $\Gamma$ is a partial function $\Gamma:Id^P\rightharpoonup TYPES$
\end{definition}
As such, $\Gamma$ represents the dependencies for variables and internal variables.

\begin{definition}[Approximated order of program points]
	An approximated order of program points $\Pi$, such that: 
	\begin{itemize}
		\item  $p\sqsubseteq p'\in\Pi$
		\item The order of program points is transitive, such that if $p\sqsubseteq p'\in\Pi$ and $p'\sqsubseteq p''\in\Pi$ then $p\sqsubseteq p''\in\Pi$.
	\end{itemize}
\end{definition}
The intuition behind an approximated order of program points is the execution order, and should as such follow all possible evaluation paths for a given program.

\iffalse
\subsection{Bases}
In the semantics, presented in \cref{sec:sem}, we keep track of dependencies through the dependency function $w$, value bindings through the environment, and location bindings through the store.

The occurrence dependency system similarly needs to keep track of dependencies.
In the system, we keep track of dependencies through the types instead of the liveness pair used in $w$.
We introduce the notion of a type dependency base $\Gamma$, that keeps track of the type of variables.

\begin{definition}[Type base]
	The type base $\Gamma$ is a partial function $\Gamma:Id^P\rightharpoonup TYPES$
\end{definition}

A lookup in the type base $\Gamma$ is of the form $\Gamma(x^p)=T$, for placeholder and imperative variables, and $\Gamma(\nu x^p)=T$, for internal variables.

\begin{definition}[Extending the type base]
	We write $\Gamma,x^p:T$ for the type base $\Gamma'$ defined by:
	\begin{align*}
		\Gamma'(y^{p'})=
		\left\{\begin{matrix}
			\Gamma(x^p) & \mbox{if}\;y^{p'} \neq x^{p}\\ 
			T & \mbox{if}\;y^{p'} = x^{p}
		\end{matrix}\right.
	\end{align*}
\end{definition}
The extension of $\Gamma$ for internal variables can be similarly defined.
\bigskip

The last base, $\Pi$, is the approximated order of program points, where we denote $p\sqsubseteq p'\in\Pi$, if $p$ is an earlier or the same program point as $p'$.
We also denote $p \sqsubset p'\in\Pi$ if $p$ is an earlier program point than $p'$.
The order of program points is also transitive, i.e., if $p\sqsubseteq p'\in\Pi$ and $p'\sqsubseteq p''\in\Pi$ then $p\sqsubseteq p''\in\Pi$.
\fi

\subsection{Judgement}
The type judgement is defined as:
$$\Gamma;\Pi\vdash e^p: T$$
And should be read as, the occurrence $e^p$ has type $T$, given the dependency bindings $\Gamma$ and the approximated order of program points $\Pi$.

\begin{definition}[$\Lambda$ function]
	Let $x^p\in \cat{Id}$, $\Gamma$ be the type base, and $\Pi$ be the approximated order of program points, the $\Lambda(x^p,\Gamma,\Pi)=x^{p'}$ is as follows
	\begin{align*}
		\Lambda(x^p,\Gamma,\Pi)=\forall x^{p''}\in dom(\Gamma). p''\sqsubset p\in\Pi\Rightarrow \exists x^{p'}\in dom(\Gamma).p''\sqsubset p\in\Pi\wedge p'\sqsubseteq p''\in\Pi
	\end{align*}
\end{definition}

\todo[inline]{Pick some examples of type system that would be good to present}


\begin{landscape}
\subfile{../examples/index.tex}
\end{landscape}

\end{document}
