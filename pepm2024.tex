\documentclass[acmsmall,sigplan]{acmart}
\input{setup/preamble-pepm2024.tex}
\input{setup/macros-pepm2024.tex}

\newcommand{\uf}{\ensuremath{\mathsf{IP}}}

\newcommand{\condinf}[3]{\begin{tabular}{l} \inference[]{#1}{#2} \\[5mm]
                          #3 \end{tabular}}
                       
%\input{frontmatter/acm.tex}

\begin{document}
\title[A type system for data flow analysis]{A type system for data
  flow and alias analysis in ReScript}

\author{Nicky Ask Lund} 
\email{nlund18@student.aau.dk} 
\affiliation{%
	\institution{Aalborg University}
	\department{Department of Computer Science}
	\city{Aalborg}
	\country{Denmark}
}

\author{Hans HÃ¼ttel} 
\email{hans.huttel@di.ku.dk} 
\affiliation{%
	\institution{University of Copenhagen}
	\department{Department of Computer Science}
	\city{Copenhagen}
	\country{Denmark}
}

\date{August 2023}

\keywords{Data-flow analysis, Alias analysis, Program analysis, Programming languages, Type systems}

\input{frontmatter/abstract.tex}

\maketitle
\renewcommand{\shortauthors}{}

\section{Introduction}

Data-flow analysis has been studied for decades in order to better
provide flow information of programs that is then used for different
tasks for compiler optimization, debugging and understanding programs,
testing and maintenance.  In the context of compiler optimization, the
flow information provides data that may be used at given parts of the
program at runtime.

The classical approach uses an iterative algorithm based on
representing the control-flow of a program as a graph.  The graph
should provide a sound over-approximation of the control flow of a
program, where edges represent the flow and nodes represent basic
blocks.  By using the information in such graphs, many algorithms have
been developed that annotate a graph and computing the maximal fixed
point of the data flow equations that arise from it
\cite{KildallGaryA1973Auat, RyderBarbara1988Idaa}.  Other techniques
have also been presented, such as graph-free approaches
\cite{HorspoolR.Niegel2002AGAt} and type systems with refinement types
\cite{PavlinovicZvonimir2021Dfrt}.

As type system have been used to provide a semantic analysis of
programs usually used to characterize specific type of run-time
errors. Type systems are implemented as either static or dynamic
analysis, i.e., on compile time or run-time.  Type systems are widely
used, from weakly typed languages such as JavaScript, to strongly
typed languages commonly found in functional languages such as Haskell
and Ocaml.

A complication arises in imperative languages that admit
references. Here one must take into account aliasing, i.e., multiple
variables referring to the same location.  Many data-flow analyses use
special alias algorithms to compute this information.  Two overall
types of alias algorithm exist. Some are flow-sensitive and give
precise information but are expensive, others are flow-insensitive and
are less precise but inexpensive \cite{LiangDonglin1999Eaag,
  EmamiMaryam1994Cipa}.

In this paper we consider the recent programming language ReScript
which is based on OCaml with a JavaScript inspired syntax which
targets JavaScript.  ReScript offers a robust type system based on
OCaml, which provides an alternative to other gradually typed
languages that targets JavaScript .\cite{rescript_rebrand}. ReScript
is also imperative and allows for mutability, through reference
constructs for creation, reading, and writing,

ReScript provides integration with JavaScript and provides its own
compiler toolchain and build system for optimizing and compiling to
JavaScript.  ReScript introduces an analysis tool for
dead-code, exception, and termination analysis, but the tool is only
experimental.\cite{reanalyze} 

We present a type system for data-flow analysis for bindings and alias
analysis in a subset of ReScript that incorporates both functional and
imperative features. The goal of the system is that it for every
location and variable occurrence will give us information about which
other, previous occurrence its value depends upon. Our type system
provides the data information used at each program point and the alias
information used.  Since the analysis we present focuses on collecting
dependencies that are used to evaluate a part of a program, this is a
local analysis.

We show that the the type system is sound in the sense that it
correctly overapproximates the set of occurrences on which any given
occurrence depends. Moreover, we present an implementation in Rust of
a type checker based on our system.

\section{A fragment of ReScript}\label{sec:lang}

The fragment of ReScript that we study here is a $\lambda$-calculus
with bindings, pattern matching and mutability. In this section we
describe the syntax of our fragment and give a big-step semantics that
is tailored to keep track of dependencies.
 
\subsection{Syntax}

The syntactic categories in our version of ReScript are
%
\begin{align*}
	e\in &\;\cat{Exp} &-\;&\mbox{Expressions} \\
	o\in &\;\cat{Occ} &-\;&\mbox{Occurrences} \\
	c\in &\;\cat{Con} &-\;&\mbox{Constants} \\
	x,\;f\in &\;\cat{Var} &-\;&\mbox{Variables} \\
	\loc\in &\;\cat{Loc} &-\;&\mbox{Constants}
\end{align*}

As the purpose of the dependency analysis is to analyse how the values
of subexpressions within a program depend upon one another, we label
every subexpression of a ReScript progra with a unique \emph{program
  points} taken from a countably infinite set $\cat{P}$. We call a
labelled expression $e^p$ where $p \in \cat{P}$ an
\emph{occurrence}. We let $u$ range over $\cat{Var} \cup
\cat{Loc}$. We call occurrences $u^p$ \emph{elements} in what follows and $u^p$
is an element, we call any other occurrence $u^q$ a \emph{$u$-occurrence}.

When given a syntactic category $\mathbf{C}$, we let $\mathbf{C}^{P}$
denote the pair $\mathbf{C}\times\cat{P}$, so that e.g.
$\cat{Exp}^\cat{P}=\cat{Exp}\times\cat{P}$. As occurrences are
labelled expressions, we have that $\cat{Occ}=\cat{Exp}^\cat{P}$.

The formation rules are shown below.
%
\begin{align*}
  \text{Occurrences} \; o &::= e^p \mid (e^{p_1}_1, \ldots,
                                 e^{p_n}_n) \\[5mm]
\text{Expressions} \; e &::= x \mid c \mid o_1\;o_2 \mid \lambda x.o\\
			& \mid c \; o_1 \; o_2\\
			& \mid \mbox{let} \; x \; o_1 \; o_2 \\
			& \mid \mbox{let rec} \; x \; o_1 \; o_2 \\
			& \mid \mbox{case} \; o_1 \; \tilde{\pi} \; \tilde{o}\\
			& \mid \mbox{ref} \; o \mid o_1 := o_2 \mid \; !o\\[5mm]
  \text{Patterns} \; \pi &::= n \mid b \mid x \mid \_  \mid
                                (s_1,\cdots,s_n)\\
\end{align*}
%
$\lambda\;x.o$ denotes an \emph{abstraction} with a parameter $x$ and body $o$.
\emph{Constants} $c$ are either natural numbers $n$, boolean values $b$, or functional constants.

\emph{Local declarations} $\mbox{let} \; x \; o_1 \; o_2$ and
$\mbox{let rec} \; f \; o_1 \; o_2$ are immutable bindings that
associate the variable $x$ with the value $o_1$ within $o_2$. The latter
form is recursive; $x$ can then appear inside $o_1$. Mutability
in ReScript is introduced using the \emph{reference} construct
$\mbox{ref\;o}$. This construct creates a reference in the form of a
location and allows for binding locations to local declarations. We
can read from a reference for $o$ by writing $!o$ and write to a
reference using the assignment construct $o_1\;:=\;o_2$. 

\emph{Pattern matching} $\mbox{case} \; o_1 \; \tilde{\pi} \; \tilde{o}$, matches an
occurrence with the ordered set, $\tilde{\pi}$, of patterns. For each
pattern in $\tilde{\pi}$ there is also an occurrence in $\tilde{o}$.
We denote the size of the tuple pattern $\pi$ by $|\tilde{\pi}|$ and
the size of a tuple occurrence by $|\tilde{o}|$.

We assume that all local bindings, and recursive bindings, are unique;
this can be ensured by means of $\alpha$-conversion.

\begin{example}[]\label{ex:write}
Consider
\begin{lstlisting}[language=Caml, mathescape=true]
  (let x (ref 3$^1$)$^2$
  (let y (let z (5$^3$)$^4$
     (x$^5$:=z$^7$)$^8$)$^{9}$ (!x)$^{10}$)$^{11}$)$^{12}$
\end{lstlisting}
This creates a reference to the constant 3 and binds the reference to
$x$ (so $x$ is an alias of this reference). Next a binding for $y$ is
made and after that a binding of $z$ to the constant 5 before writing
to the reference, that $x$ is bound to, to the value that $z$ is bound
to.  Finally the reference that $x$ is bound to is read. We expect to
retrieve the value $5$.
\end{example}

The notions of free and bound variables are defined as expected.

\subsection{The binding model}\label{sec:EnvSto}

We now present the binding model used in the semantics that
follows. As we are dealing with an imperative language with
references, we use an environment-store model. The environment keeps
track of bindings of variables to values. Our fragment of ReScript
contains the imperative constructs of mutability and referencing, so
values can be locations.

Moreover, as our language has first-class functions, values can also be closures.
We have that
\begin{itemize}
	\item All constants are values.
	\item Locations are values.
	\item Closures, $\langle x,e^{p'},env\rangle$ are values.
	\item Recursive closures, $\langle x,f,e^{p''},env\rangle$, are values.
	\item Unit values, $()$, are values.
\end{itemize}

and we let $v$ range over \cat{Values}.

\begin{definition}
	The set of all environments, \cat{Env}, is the set of partial functions from variables to values, given as:
	$$\cat{Env}=\cat{Var}\rightharpoonup\cat{Values}$$
\end{definition}
%
Here $env\in\cat{Env}$ denotes an arbitrary environment in \cat{Env}.

The set of variables bound to any given value $v$ in $env$ is defined by 
\begin{definition}
  Let $v$ be a value and $env\in\cat{Env}$ be an environment. The
  inverse $env^{-1} : \cat{Values} \to \cat{2}^{\cat{var}}$
  is defined by
  %
	\[ env^{-1}(v)=\{x\in dom(env)\mid env(x)=v\} \]
\end{definition}
%
We use a store to keep the information about values bound to locations
and introduce a placeholder $next$ that represents the next free location.

\begin{definition}
	The set of all stores, \cat{Sto}, is the set of partial functions from locations and the $next$ pointer to values.
\[ \cat{Sto}=\cat{Loc}\cup\{next\}\rightharpoonup\cat{Values} \]
We let $sto\in\cat{Sto}$ denote an arbitrary store in \cat{Sto}.
\end{definition}

Moreover, we assume the existence of a function
$new:\cat{Loc}\rightarrow\cat{Loc}$, which takes a location and finds
the next location.

For any function $f$ appearing in our binding model and in the
dependency model in Section \ref{sec:DepFunc} we let $f[u
\mapsto w]$ denote the function $f'$ such that $f(u') = f(u)$ for $u
\neq u'$ and $f'(u') = w$.

\subsection{Keeping track of dependencies}\label{sec:DepFunc}

The goal of the semantics that follows is to collect the semantic
dependencies as they appear in a computation. To this end, we use a
dependency function that will tell us for each variable and location
occurrence what other, previous occurrences they depend upon.

\begin{definition}[Dependency function]\label{def:DepFunc}
	The set of dependency functions, $\cat{W}$, is a set of partial functions from location and variable occurrences to a pair of dependencies, such that:
\[
  \cat{W}=\cat{Loc}^P\cup\cat{Var}^P\rightharpoonup\Pow{\cat{Loc}^P}\times\Pow{\cat{Var}^P} \] 
\end{definition}
For a dependency function $w$ and an
$u^p\in\cat{Loc}^P\cup\cat{Var}^P$,
%
\[ w (u^p)=(\{\loc_1^{p_1},\cdots,\loc_n^{p_n}\},\{x_1^{p'_1},\cdots,x_m^{p'_m}\}) \]
%
should be read as: a lookup of an occurrence $u^p$, a variable or
location occurrence, returns a pair of location and variable
occurrences.  We also denote the pair, retrieved from the dependency
function, which we call a dependency pair such that $(L,V)$ contains a
set of location occurrences $L$ where
$L=\{\loc_1^{p_1},\cdots,\loc_n^{p_n}\}$ and a set of variable
occurrences $V$ where $V=\{x_1^{p'_1},\cdots,x_m^{p'_m}\}$.

\begin{example}[]\label{ex:dep}
	Consider the occurrence from \cref{ex:write}, where we can
        infer the following bindings for a dependency function
        $w_{ex}$ over this occurrence: 
	\[
          w_{ex}= \begin{array}{l}
                    [x^2\mapsto(\emptyset,\emptyset),z^4\mapsto(\emptyset,\emptyset),y^9\mapsto(\emptyset,\{x^5\}),
                    \\ \; \loc^2\mapsto(\emptyset,\emptyset),\loc^8\mapsto(\emptyset,\{z^7\})] \end{array} \]
	where $\loc$ is the location created from the reference construct.
	The variable bindings are distinct, an the location $\loc$ is
        bound multiple times, for the program points $2$ and $8$. 

	If we want to read a variable or location in $w_{ex}$, we must
        also know for which program point since there can exists
        multiple bindings for the same variable or location. 
\end{example}

By considering \cref{ex:dep}, we would like to read the information from the location, that $x$ is an alias to.
As it is visible from the occurrence in \cref{ex:write}, we know that we should read from $\loc^8$, since we wrote that reference at the program point $8$.
We can also see that from $w_{ex}$ alone it is not possible to know which occurrence to read, since there are no order defined between the bindings.
We there introduce a notion of ordering in the form of a binary relation over program points:

\begin{definition}[]\label{def:BinRel}
	Let \cat{P} be a set of program points in an occurrence.
	Then $\sqsubseteq$ is a binary relation of \cat{P}, such that:
	$$\sqsubseteq\subseteq\cat{P}\times\cat{P}$$
\end{definition}

Since we are interested in the ordering of the elements in a
dependency function $w$, we will define an instantiation of
\cref{def:BinRel}. 
Since $w$, is a function from occurrences to a pair of occurrences, we
first present a function for getting the program points from a set of
occurrences: 

\begin{definition}[Occurring program points]\label{def:OccPP}
	Let $O$ be a set of occurrences, then $points(O)$ is given by:
	$$points(O)=\{p\in\cat{P}\mid\exists e^p\in O\}$$
\end{definition}

With \cref{def:OccPP} defined, we present the instantiation of \cref{def:BinRel} over a dependency function $w$:

\begin{definition}[]\label{def:RelPoint}
	Let $w\in\cat{W}$ be a dependency function.
	Then $\sqsubseteq_w$ is given by:
	$$\sqsubseteq_w\subseteq\{(p,p')\mid p,p'\in(points(dom(w)\cup points(ran(w))))\}$$
\end{definition}

As the dependency function $w$ is a model of which occurrences an occurrence is dependent on, the relation on $w$ should also model the order a value is evaluated in, as such we define the partial order over a dependency function.

\begin{definition}[Partial order of $w$]
	Let $w\in\cat{W}$ be a dependency function and $\sqsubseteq_w$ be a binary relation over $w$.
	We say that $w$ is partial order if $\sqsubseteq_w$ is a partial order.
\end{definition}

\begin{example}[]\label{ex:depRel}
	Consider the example from \cref{ex:dep}, if we introduce a binary relation over the dependency function $w_{ex}$, such that:
	$$\sqsubseteq_{w_{ex}}=\{(2,4),(2,9),(5,9),(2,8),(8,2)\}$$
	From this ordering, it is easy to see the ordering of the elements.
	The ordering we present also respects the flow the occurrence from \cref{ex:write} would evaluate to.
	We then know that the dependencies for the reference (that $x$ is an alias to) is for the largest binding of $\loc$.
\end{example}

As presented in \cref{def:DepFunc} and \cref{def:RelPoint}, the
dependency function and the binary relation are used to define the
flow of information. As illustrated by \cref{ex:depRel}, we need to
lookup the greatest of $\sqsubseteq_w$. 

The immediate predecessor $\uf(u,S)$ of an element $u^p$ wrt. a set of occurrences $S$ is
the most recent $u$-element in $S$ seen before $u$. 

\begin{definition}[Immediate predecessor]\label{def:GBind}
  Let $u$ be an element and $S$ be a set of occurrences, then
  $\uf(u,S)$ is given by
\[ \uf(u^p,S)=\inf\{u^q\in S\mid q\sqsubseteq p\} \]
\end{definition}

Based on \cref{def:GBind}, we can present an instantiation of the function for the dependency function $w$ and an order over $w$, $\sqsubseteq_w$:

\begin{definition}[]
	Let $w$ be a dependency function, $\sqsubseteq_w$ be an order over $w$, $u$ be an element, that is either a variable or location, then $\uf_{\sqsubseteq_w}$ is given by:
	$$\uf_{\sqsubseteq_w}(u,w)=\inf\{u^p\in dom(w)\mid u^q\in dom(w.q\sqsubseteq_w p\}$$
\end{definition}


\begin{example}[]\label{ex:deplookup}
	As a continuation of \cref{ex:depRel}, we can now lookup the greatest element for an element, e.g., a variable or location.
	As we were interested in finding the greatest bindings a location is bound to in $w_ex$, we can now use the function $\uf_{\sqsubseteq_w}$:
	$$\uf_{\sqsubseteq_{w_ex}}(\loc,w_ex)=\inf\{\loc^p\in dom(w)\mid \loc^q\in dom(w). q\sqsubseteq_{w_ex} p\}$$
	Where the set we get for $\loc$ are as follows: $\{\loc^2,\loc^8\}$.
	From this, we find the greatest element:
	$$\loc^7=\inf\{\loc^2,\loc^8\}$$
	As we can see, from the $\uf_{w_ex}$ function, we got $\loc^8$ which were the occurrence we wanted.
\end{example}

\subsection{Collection semantics}\label{sec:sem}

We can now introduce the big-step semantics for our language that
collects dependency information. In this semantics, the transitions
are of the form
%
\begin{align*}
env\vdash\left\langle e^{p'},sto,(w,\sqsubseteq_w),p\right\rangle\rightarrow\left\langle v,sto',(w',\sqsubseteq_w'),(L,V),p''\right\rangle
\end{align*}
%
This should be read as: given the store $sto$, a dependency function
$w$, a relation over $w$, and the previous program point $p$, the
occurrence $e^{p'}$ evaluates to a value $v$, an updated store $sto'$,
an updated dependency function $w'$, a relation over $w'$, the
dependency pair $(L,V)$, and the program point $p''$ reached after
evaluating $e^{p'}$, given the bindings in the environment $env$. 

A selection of the rules for $\rightarrow$ can be found in \cref{fig:ColSem}.

\begin{description}
	\item[\runa{Const}] rule, for the occurrence $c^{p'}$, is the simplest rule, as it has no premises and does not have any side effects.
		As constants are evaluated to the constant value, no dependencies are used, i.e., no variable or location occurrences are used to evaluate a constant.

	\item[\runa{Var}] rule, for the occurrence $x^{p'}$, uses the environment to get the value $x$ is bound to and uses dependency function $w$ to get its dependencies.
		To lookup the dependencies, the function $\uf_{\sqsubseteq_w}$ is used to get the greatest binding a variable is bound to, in respect to the ordering $\sqsubseteq_w$.
		Since the occurrence of $x$ is used, it is added to the set of variable occurrences we got from the lookup of the dependencies for $x$.

	\item[\runa{Let}] rule, for the occurrence $[\mbox{let}\;x\;e_1^{p_1}\;e_2^{p_2}]^{p'}$, creates a local binding that can be used in $e_2^{p_2}$.
		The \runa{Let} rule evaluate $e_1^{p_1}$, to get the value $v$, that $x$ will be bound to in the environment for $e_2^{p_2}$, and the dependencies used to evaluate $e_1^{p_1}$ is bound in the dependency function.
		As we reach the program point $p_1$ after evaluating $e_1^{p_1}$, and it is also the program point before evaluating $e_2^{p_2}$, the binding of $x$ in $w$ is to the program points $p_1$.	

	\item[\runa{Ref}] rule, for the occurrence $[\mbox{ref}\;e^{p'}]^{p''}$, creates a new location and binds it in the store $sto$, to the value evaluated from $e^{p'}$.
		The \runa{Ref} rule also binds the dependencies, from evaluating the body $e^{p'}$, in the dependency function $w$ at the program point $p''$.
		As the \runa{Ref} rule creates a location (where we get the location from the $next$ pointer), and binds it in $sto$.
		The environment is not updated as \runa{Ref} does not in itself give any alias information.
		To create an alias for a location, it should be bound to a variable using the \runa{Let} rule.

	\item[\runa{Ref-read}] rule, for the occurrence $[!e^{p_1}]^{p'}$, evaluates the body $e^{p_1}$ to a value, that must be a location $\loc$, and reads the value of $\loc$ in the store.
		The \runa{Ref-read} rule also makes a lookup for the dependencies $\loc$ is bound to in the dependency function $w$.
		As there could be multiple bindings for $\loc$, in $w$, at different program points, we use the $\uf_{\sqsubseteq_{w'}}$ function to get greatest binding of $\loc$ with respect to the ordering $\sqsubseteq_{w'}$, 
		and we also add the location occurrence $\loc^{p'}$ to the set of locations.

	\item[\runa{Ref-write}] rule, for the occurrence $[e_1^{p_1}\;:=\;e_2^{p_2}]^{p'}$, evaluate $e_1^{p_1}$ to a location $\loc$ and $e_2^{p_2}$ to a value $v$, and binds $\loc$ in the store $sto$ to the value $v$.
		The dependency function is also updated with a new binding for $\loc$ at the program point $p'$.
\end{description}

\begin{table*}
%	\setlength\tabcolsep{8pt}
	\begin{tabular}{l}
          \runa{Var}\\[0.2cm]
	\inference[]{}
	{env\vdash \left\langle x^{p'},sto,(w,\sqsubseteq_w),p \right\rangle \rightarrow \left\langle v,sto,(w,\sqsubseteq_w),(L,V\cup\{x^{p'}\}),p' \right\rangle}\\[6mm]
	where $env(x)=v$, $x^{p''}=\uf_{\sqsubseteq_w}(x,w)$, and
          $w(x^{p''})=(L,V)$ \\[4mm]
	\inference[]{}
	{env\vdash \left\langle x^{p'},sto,(w,\sqsubseteq_w),p \right\rangle \rightarrow \left\langle v,sto,(w,\sqsubseteq_w),(L,V\cup\{x^{p'}\}),p' \right\rangle}\\[6mm]
	where $env(x)=v$, $x^{p''}=\uf_{\sqsubseteq_w}(x,w)$, and $w(x^{p''})=(L,V)$
          \\[4mm]
	\inference[]
	{
		env\vdash \left\langle e_1^{p_1},sto,(w,\sqsubseteq_w),p \right\rangle \rightarrow \left\langle v_1,sto_1,(w_1,\sqsubseteq_w^1),(L_1,V_1),p_1 \right\rangle &\\
		env[x\mapsto v_1]\vdash \left\langle e_2^{p_2},sto_1,(w_2,\sqsubseteq_w^1),p_1 \right\rangle \rightarrow \left\langle v,sto',(w',\sqsubseteq_w'),(L,V),p_2 \right\rangle
	}
	{env\vdash \left\langle \left[\mbox{let}\;x\;e_1^{p_1}\;e_2^{p_2}\right]^{p'},sto,(w,\sqsubseteq_w),p \right\rangle \rightarrow \left\langle v,sto',(w',\sqsubseteq_w'),(L,V),p' \right\rangle}\\[6mm]
	where $w_2=w_1[x^{p_1}\mapsto(L,V)]$
          \\[4mm]
          \runa{Ref}\\
	\inference[]
	{env \vdash \left\langle e^{p'},sto,(w,\sqsubseteq_w),p \right\rangle \rightarrow \left\langle v,sto',(w',\sqsubseteq_w'),(L,V),p' \right\rangle}
	{env\vdash \left\langle \left[\mbox{ref}\;e^{p'}\right]^{p''},sto,(w,\sqsubseteq_w),p \right\rangle \rightarrow \left\langle \loc,sto'',(w'',\sqsubseteq_w'),(\emptyset,\emptyset),p'' \right\rangle}\\[6mm]
	where $\loc=next$, $sto''=sto'[next\mapsto new(\loc),\loc\mapsto v]$, and\\
          $w''=w'[\loc^{p'}\mapsto (L,V)]$ \\[4mm]
 \runa{Ref-read}\\
	\inference[]
	{env \vdash \left\langle e^{p_1},sto,(w,\sqsubseteq_w),p \right\rangle \rightarrow \left\langle \loc,sto',(w',\sqsubseteq_w'),(L_1,V_1),p_1 \right\rangle}
	{env\vdash \left\langle \left[!e^{p_1}\right]^{p'},sto,(w,\sqsubseteq_w),p \right\rangle \rightarrow \left\langle v,sto',(w',\sqsubseteq_w'),(L\cup L_1\cup\{\loc^{p''}\},V\cup V_1),p' \right\rangle}\\[6mm]
	where $sto'(\loc)=v$,
          $\loc^{p''}=\uf_{\sqsubseteq_w'}(\loc,w')$, and
          $w'(\loc^{p''})=(L,V)$ \\[4mm]
\runa{Ref-write}\\
	\inference[]
	{
		env \vdash \left\langle e_1^{p_1},sto,(w,\sqsubseteq_w),p \right\rangle \rightarrow \left\langle \loc,sto_1,(w_1,\sqsubseteq_w^1),(L_1,V_1),p_1 \right\rangle &\\
		env \vdash \left\langle e_2^{p_2},sto_1,(w_1,\sqsubseteq_w^1),p_1 \right\rangle \rightarrow \left\langle v,sto_2,(w_2,\sqsubseteq_w^2),(L_2,V_2),p_2 \right\rangle
	}
	{env\vdash \left\langle \left[e_1^{p_1}:=e_2^{p_2}\right]^{p'},sto,(w,\sqsubseteq_w),p \right\rangle \rightarrow \left\langle (),sto',(w',\sqsubseteq_w'),(L_1,V_1),p' \right\rangle}\\[6mm]
	where $sto'=sto_2[\loc\mapsto v]$, $\loc^{p''}=inf_{\sqsubseteq_w^2}(\loc,w_2)$,\\
	$w'=w_2[\loc^{p'}\mapsto(L_2,V_2)]$, and
          $\sqsubseteq_w'=\sqsubseteq_w^2\cup(p'',p')$ \\[6mm]
	\end{tabular}
	\caption{Selected rules from the semantics}
	\label{fig:ColSem}
\end{table*}

\iffalse
\begin{example}[Data-flow for abstractions]\label{ex:DFAbs}
The following program creates a local binding to the identity function and applies it twice.

\begin{lstlisting}[language=Caml, mathescape=true]
(let x ($\lambda$ y.(y$^1$))$^2$ (let z (x$^3$ 1$^4$)$^5$ (x$^6$ 2$^7$)$^{8}$)$^{9}$)$^{10}$
\end{lstlisting}
The transition tree can be found in \cref{FigEx.Abs}.
In the transition tree, we see that $\psi$ is extended a couple of times, where we will take a look at a couple of interesting extensions to $\psi$
The first time we evaluate the abstraction body, $\psi$ is on the following form:

$$\psi_2=(w_2=[x^{2}\mapsto(\emptyset,\emptyset), y^{4}\mapsto(\emptyset,\emptyset)],\sqsubseteq_w^2=\emptyset)$$
Here, the lookup of the parameter $y$ is simple, as there are only one occurrence, where we then know that $inf_{\psi_2}(y)=4$.

The second time we evaluate the body of the abstraction, $\psi$ is 
%
\[ \psi_3=(w_3=[x^{2}\mapsto(\emptyset,\emptyset),
  y^{4}\mapsto(\emptyset,\emptyset),
  y^{7}\mapsto(\emptyset,\emptyset)],\sqsubseteq_w^2=\{4,7\}) \]
Here, we now have two bindings for the parameter $y$, but since we also know that there are an ordering for the two occurrences of $y$, we then know that the program point $7$ is evaluated after $4$, as such we know that $inf_{\psi_3}(y)=7$.
\end{example}

\begin{landscape}
\subfile{../examples/DFAbs.tex}
\end{landscape}
\fi

\section{A type system for data-flow analysis}\label{sec:TypeSys}

The the type system for data-flow analysis is an overapproximation of
the big-step semantics.

\subsection{An overview of the type system}

The system assigns types, presented in \cref{sec:types}, to
occurrences given the basis, which will be presented in
\cref{sec:basis}, and using the type assignment, which is presented in
\cref{sec:Judge}. 
Since the language contains local information as bindings, and global
information as locations, the type checker must reflect this.

Since locations are a semantic notation, we introduce a notion of
\emph{internal} variables to represent them in the type
system. Internal variables are denoted by
$\nu x,\; \nu y\in\cat{IVar}$ and \cat{IVar} is the syntactic category
for internal variables.

As references are not always bound to variables, as such the reference
does not contain any alias information, the analysis provides alias
information used for evaluating an occurrence.  Here, we are going to
introduce the basis for aliasing, as a partition of the sets of
variables and internal variables used in an occurrence.  As such, it
becomes possible to use the type information of occurrences to
determine which aliases are actually used.

We also impose some restrictions on the type system, where the first
restrictions is that references cannot be bound to abstractions.
Since we do not introduce polymorphism into our type system, an abstraction can only be
used once. 
Consider the following occurrence:
\begin{lstlisting}[language=Caml, mathescape=true]
(let x ($\lambda$ y.y$^1$)$^2$ (x$^3$ (x$^4$ 1$^5$)$^6$)$^7$)$^8$
\end{lstlisting}
To type the occurrences used in both places where we apply the
abstractions, we type of the argument in the innermost application is
empty, as it applies a constant. 
For the second, and outermost, application, the argument type must
contain the occurrence $x^4$, as it were used to evaluate the value
for the argument. 

\subsection{Types}\label{sec:types}

The set of types \cat{Types} is defined by the following formation rules:
%
\[ T ::=(\delta,\kappa)\mid T_1 \rightarrow T_2 \]
%
Here, we introduce two types, the base type $(\delta,\kappa)$ and the
abstraction type $T_1 \rightarrow T_2$.

The base type $(\delta,\kappa)$ contains a set $\delta$ that contains
the set of occurrences upon the value of a occurrence can at most
depend, and $\kappa$ represents alias information in the form of the
set of internal variables upon which this occurrence may
depend. Therefore, if an occurrence has a base type where
$\kappa/neq \emptyset$, then the occurrence must represent a location.

In order to be able to type functions, we introduce arrow types
$T_1 \rightarrow T_2$. If an occurrence has the
abstraction type where either $T_1$ or $T_2$ are base types with alias
information, then the abstraction either takes a reference as input or
returns a reference.

\begin{example}[]
Consider the following occurrence:
\begin{lstlisting}[language=Caml, mathescape=true]
(let x (3$^1$)$^2$ (let y (ref x$^3$)$^4$ (!y)))
\end{lstlisting}
Here, we can type $x$ with $(\emptyset,\emptyset)$ as $x$ is bound to a constant and there a no variables or internal variables used.
$y$ can then be given the type $(\emptyset,\{x,\nu y\})$, as the reference construct $ref$ creates a new reference, which $y$ is then an alias to, e.g., $y$ is bound to a location.
Her $\nu y$ represents the reference from $ref$, and can thus be given the type $(\{x^3\},\emptyset)$, where $\nu y$ is bound to a constant, because of $x$, but the occurrence $x^3$ were used, so it should be part of the set of occurrences $\delta$.
\end{example}

Since the type system approximates the occurrences used to evaluate an occurrence, we introduce two unions.
The first union is a simple union that expects the types to be similar, that is, only the base types are allowed to be different.

\begin{definition}
  	Let $T_1$ and $T_2$ be two types, then their union is defined as

  \[
T_1\cup T_2=
    \begin{cases}
      (\delta\cup\delta',\kappa\cup\kappa') & \begin{array}{l}
                                                T_1=(\delta,\kappa) \\
      T_2=(\delta',\kappa') \end{array} \\[3mm]
       (T_1'\cup T_2')\rightarrow (T_1''\cup T_2'') &
       \begin{array}{l} T_1=T_1'\rightarrow T_1'' \\;T_2=T_2'\rightarrow
       T_2''  \end{array}\\[3mm]
       (\delta' \cup \delta, \kappa \cup \kappa') & \begin{array}{l}
                                                      T_1 =
                                                      (\delta',\kappa') \\
                                                      T_2 =
                                                      (\delta,\kappa) \end{array}
                                                    \\[3mm]
       \text{undefined} & \text{otherwise}
    \end{cases}
\]
\end{definition}
% The second type union, is to add additional type information to an arbitrary type.
% This type union is used to add an occurrence to a type, e.g., in the \runa{Var} rule where the variable occurrence needs to be added to the type of that variable.
% \begin{definition}[Base type union]
% 	Let $T$ be an type and $(\delta,\kappa)$ be a base type, then the union of these are as follows:
% 	\begin{equation*}
% 		T\sqcup (\delta,\kappa)=
% 		\left\{\begin{matrix}
% 			\mbox{If } \; T=(\delta',\kappa')  & \mbox{then} \; (\delta\cup\delta',\kappa\cup\kappa')\\
% 			\mbox{else if } \; T=T_1\rightarrow T_2 & \mbox{then} \; T_1\rightarrow(T_2\sqcup (\delta,\kappa))
% 		\end{matrix}\right.
% 	\end{equation*}
% \end{definition}

\subsection{The binding model of the type system}\label{sec:basis}

The semantics will let us find dependency information, and the type 
system most approximate these semantic notions.

As locations do not appear at the level of the type system, we
introduce the notion of a type base. This is a partitioning of the
sets of variables and internal variables. 

\begin{definition}[Type Base for aliasing]
	For an occurrence $o$, let $\cat{Var}_o$ be the set of all
        variables found in $o$ and $\cat{IVar}_o$ be the set of all
        internal variables in $o$ found in $o$.
	The type base $\kappa^0=\{\kappa^0_1,\cdots,\kappa^0_n\}$ is
        then a partition of $\cat{Var}_o \cup \cat{IVar}_o$, where
        $\kappa_i^0\cap\kappa_j^0=\emptyset$ for all $i\neq j$. 
\end{definition}

This partition represents the assumption about which variables are
actually an alias to internal variables: If $x \in \kappa^0_1$ and
$\nu y \in \kappa^0_i$, then $x$ is an alias of $\nu y$.

As such multiple variables can only belong to the same element
$\kappa_0^i\in\kappa_0$, if there also exists an internal variable in
$\kappa_0^i$. 

We also assume an ordering of program points at type level.

\begin{definition}[Approximated order of program points]
	An approximated order of program points $\Pi$ is a pair, such that: 
	$$\Pi=(\cat{P},\sqsubseteq_\Pi)$$
	where
	\begin{itemize}
		\item \cat{P} is the set of program points in an occurrence,
		\item $\sqsubseteq_\Pi\subseteq\cat{P}\times\cat{P}$, where
	\end{itemize}
\end{definition}

The approximated order of program points is an assumption about the
order for program points for an occurrence $o$, as such, this
approximation should be an approximation of the order that that can be
derived from the semantics, presented in \cref{sec:sem}, for $o$. 

\begin{definition}[Partial order of $\Pi$]
	Let $\Pi=(\cat{P},\sqsubseteq_\Pi)$ be an approximated order of program points.
	We say that $\Pi$ is a partial order if $\sqsubseteq_\Pi$ is a partial order.
\end{definition}
\bigskip

A type environment tells us the types of occurrences of variables and
internal variables.

\begin{definition}[Type Environment]
	A type environment $\Gamma$ is a partial function $\Gamma:\cat{Var}^P\cup\cat{IVar}^P\rightharpoonup\cat{Types}$
\end{definition}

\begin{definition}[Updating a type environment]
	Let $\Gamma$ be a type environment.
	We write $\Gamma[u^p:T]$, for an occurrence $u^p$, to denote the type environment $\Gamma'$ where:
	\begin{align*}
		\Gamma'(y^{p'})=
		\left\{\begin{matrix}
			\Gamma(y^{p'}) & \mbox{if}\;y^{p'}\neq u^{p}\\\	 
			T & \mbox{if}\;y^{p'}=u^{p}
		\end{matrix}\right.
	\end{align*}
\end{definition}

The notion of the immediate predecessor of a $u$ at type level is
relative to a type environment $\Gamma$ and the approximated order
$\Pi$. Since we do not have locations at the level of the type system,
$u$ will now be either a variable or an internal variable.

\begin{definition}[Immediate predecessor at type level]\label{def:GBindPi}
	Let $u\in \cat{Var}\cup\cat{IVar}$, be either a variable or
        internal variable, $\Gamma$ be a type environment, and $\Pi$
        be the approximated order of program points that is a partial
        order, then $uf_{\sqsubseteq_\Pi}$ is given by: 
	\[ \uf_{\sqsubseteq_\Pi}(u,\Gamma)=\inf\{u^p\in
          dom(\Gamma)\mid u^q\in dom(\Gamma).q\sqsubseteq_\Pi p\} \]
\end{definition}

Where the lookup for global information needs to be handled differently as the language contains pattern matching, and as such, the language can contain different path of evaluation (where each pattern in the pattern matching construct introduces a new path).
To handle the lookup of global information, we will first introduce the notion of $p$-chains as chains of program points with respect to the approximated order of program points, where the maximal program point is $p$.
The idea of these $p$-chains is to describe the history behind an occurrence $u^p$, and can thus be used to describe what an internal variable depends on.

\begin{definition}[$p$-chains]
	Let $\Pi$ be an approximated order of program points, that is a partial order, and $p$ be a program point.
	We then say that a $p$-chain, denoted as $\Pi_p^{*}$, is a maximal chain of with the maximal element $p$ with the respect to the order $\Pi$.
	As such, any $p$-chain is a total order, where $\Pi_p^{*}$ does not contain any pairs $(p,q)\in\sqsubseteq_\Pi$, where $p\neq q$, then $(p,q)\notin\sqsubseteq_{\Pi_p^{*}}$.
\end{definition}

We also denote $\Pi_p^{*}\in\Pi$, if the $p$-chain $\Pi_p^{*}$ can be be derived from $\Pi$.
Since there can exists multiple paths in an occurrence, we define the set of all $p$-chains as follows:

\begin{definition}[]
	Let $\Pi$ be an approximated order of program points and $p$ be a program point.
	We say that $\Upsilon_p$ is the set of all $p$-chains in $\Pi$.
\end{definition}

Since $\Upsilon_p$ contains all $p$-chains in an approximated order of program points $\Pi$, with $p$ as the maximal element, we can then define the function to lookup all greatest element less than or equal to $p$.

\begin{definition}[]\label{def:GBindUps}
	Let $u\in \cat{Var}\cup\cat{IVar}$, be either a variable or internal variable, $\Gamma$ be a type environment, and $\Upsilon_p$ be a set of $p$-chains, then $uf_{\Upsilon_p}$ is given by:
	$$uf_{\Upsilon_p}(u,\Gamma)=\bigcup_{\Pi_p^{*}\in\Upsilon_p}uf_{\Pi_p^{*}}(u,\Gamma)$$
\end{definition}

The function, defined in \cref{def:GBindUps}, takes the union of the greatest binding, for an element, for each $p$-chain using the function defined in \cref{def:GBindPi}.

\subsection{The type system}\label{sec:Judge}
We will now present the judgement and type rules for the language, that is, how we assign types to occurrences.

Type judgements have the format
%
\[ \Gamma,\Pi\vdash e^p: T \]
%
and should be read as: the occurrence $e^p$ has type $T$, given the
dependency bindings $\Gamma$ and the approximated order of program
points $\Pi$. 

A highlight of type rules can be found in \cref{fig:TypeSys}.

\begin{description}
	\item[\runa{T-Const}] rule, for occurrence $c^p$, is the simplest type rule, as there is nothing to track for constants, and as such it has the type $(\emptyset,\emptyset)$.

	\item[\runa{T-Var}] rule, for occurrence $x^p$, looks up the type for $x$ in the type environment, by finding the greatest binding using \cref{def:GBindPi}, and add the occurrence $x^p$ to the type.

	\item[\runa{T-Let-1}] rule, for occurrence $[\mbox{let}\;x\;e_1^{p_1}\;e_2^{p_2}]^p$, creates a local binding for a variable, with the type of $e_1^{p_1}$ that can be used in $e_2^{p_2}$.
		The \runa{T-Let-1} rule assumes that the type of $e_1^{p_1}$ is a base type with alias information, i.e., $\kappa\neq\emptyset$.
		If this is the case, then $e_1^{p_1}$ must evaluate to a location, in the semantics.
		The other cases, when $e_1^{p_1}$ is not a base type with alias information, are handled by the \runa{T-Let-2} rule.
		Since a pattern can be a variable, we updates the type environment with the type of $e^p$.

	\item[\runa{T-Case}] rule, for occurrence $[\mbox{case}\;e^{p}\;\tilde{\pi}\;\tilde{o}]^{p'}$, is an over-approximation of all cases in the pattern matching expression, by taking an union of the type of each case.
		Since the type of $e^p$ is used to evaluate the pattern matching, we also add this type to the type of the pattern matching.

	\item[\runa{T-Ref-read}] rule, for occurrence $[!e^{p}]^{p'}$, is used to retrieve the type of references, where $e^p$ must be a base type with alias information.
		Since the type system is an over-approximation, there can be multiple internal variables in $\kappa$ and multiple occurrences we need to read from.
		As such we need to lookup for all internal variables and also possible for multiple program points.
		As such, we use the $uf_{Upsilon_{p'}}$ to lookup for all $p'$-chains.
\end{description}

% \begin{example}[Data-flow for abstractions]
% 	Consider the following occurrence for application:
% 	\begin{lstlisting}[language=Caml, mathescape=true]
% 		(($\lambda$ y.(PLUS 3$^1$ y$^2$)$^3$)$^4$ 5$^5$)$^6$
% 	\end{lstlisting}
% 	The derivation tree for the occurrence can be found in \cref{FigEx.TAbs}.
% 	Here, we show two applications, for \runa{T-App} and \runa{T-App-const}, where we create an abstraction that adds the constant $3$ to the argument of the abstraction, and applying the constant $5$ to the abstraction.

% 	When typing the abstraction, we need too make an assumption about the parameter $y$ and the body.
% 	As we are applying a constant to the argument, we can make an assumption that the type of the parameter should be $(\emptyset,\emptyset)$.

% 	Based on this assumption for the type, we can then type the body of the abstraction.
% 	As the body is an application for a functional constant, \runa{T-App-const}, we take a union for the types of each argument.
% \end{example}

% \begin{example}[Data-flow for references]
% 	Consider the following occurrence:
% 	\begin{lstlisting}[language=Caml, mathescape=true]
%           (let x (ref 1$^1$)$^2$
%           (let y (x$^3$) (!x$^4$)$^5$)$^6$)$^7$
% 	\end{lstlisting}
% 	The derivation tree for the occurrence can be found in \cref{FigEx.TRef}.
% 	Here, we show the typing of references where we create a reference and create 2 aliases for it before reading from the reference.
% 	When typing the reference, it modifies the base type $\Gamma$ with a new internal variable.
% 	From the type information, it is clear that only $x$ and the internal variable $\nu x$ is used.
% \end{example}

\begin{table*}
	\setlength\tabcolsep{8pt}
	\begin{tabular}{llll}
\runa{T-Const} &
	\inference[]{}
	{\Gamma,\Pi\vdash  c^{p}:(\emptyset,\emptyset)} & 
\runa{T-Var} &
	\condinf{}
	{\Gamma,\Pi \vdash x^p:T \sqcup (\{x^p\},\emptyset)}{where 
	$x^{p'}=uf_{ \sqsubseteq_\Pi}(x,\Gamma)$, and
          $\Gamma(x^{p'})=T$} \\[15mm]
\runa{T-Let-1} &
	\condinf{
		\Gamma,\Pi\vdash e_1^{p_1}:(\delta,\kappa) \\
		\Gamma',\Pi\vdash e_2^{p_2}:T_2
	}
	{\Gamma,\Pi\vdash [\mbox{let}\; x \; e_1^{p_1} \; e_2^{p_2}]^{p}:T_2}{where $\Gamma'=\Gamma[x^{p}:(\delta,\kappa\cup \{x\})]$ and
          $\kappa\neq\emptyset$} &
\runa{T-Case} &
	\condinf
	{
		\Gamma,\Pi\vdash e^{p}:(\delta,\kappa) \\
		\Gamma',\Pi\vdash e_i^{p_i}:T_i\;\;\;(1\leq i\leq|\tilde{\pi}|)
	}
	{\Gamma,\Pi\vdash [\mbox{case}\;e^{p}\;\tilde{\pi}\;\tilde{o}]^{p'}:T\sqcup(\delta,\kappa)}
	{where $e_i^{p_i}\in\tilde{o}$ and $s_i\in\tilde{\pi}$ $T=\bigcup_{i=1}^{|\tilde{\pi}|}T_i$, and\\
          $\Gamma'=\Gamma[x^p:(\delta,\kappa)]$ if $s_i=x$} \\[18mm]
\runa{T-Ref-read} &
	\multicolumn{3}{l}{\condinf
	{\Gamma,\Pi\vdash  e^{p}:(\delta,\kappa)}
	{\Gamma,\Pi\vdash
                    [!e^{p}]^{p'}:T\cup(\delta\cup\delta',\emptyset)}
                   % {a}}
	{where $\left\{\begin{array}{l}\kappa\neq\emptyset$, $\delta'=\{\nu x^{p'}\mid\nu x\in\kappa\}$, $\nu x_1,\cdots,\nu x_n\in\kappa\\ 
	\{\nu x_1^{p_1},\cdots,\nu x_1^{p_m}\}=uf_{\Upsilon_{p'}}(\nu
                  x_1,\Gamma),\cdots,\{\nu x_n^{p_1'},\cdots,\nu
                  x_n^{p_s'}\}=uf_{\Upsilon_{p'}}(\nu x_n,\Gamma) \\
	T=\Gamma(\nu x_1^{p_1})\cup\cdots\cup\Gamma(\nu
                         x_1^{p_m})\cup\cdots\cup\Gamma(\nu
                         x_n^{p_1'})\cup\cdots\cup\Gamma(\nu
                         x_n^{p_s'})\end{array}\right\}$}} \\
          & & &
	\end{tabular}
	\caption{Selected rules from the type system}
	\label{fig:TypeSys}
\end{table*}

% \begin{landscape}
% \subfile{../examples/DFAbsT.tex}
% \end{landscape}

\section{Soundness}\label{sec:Soundness}

We will now show the soundness of the type system, i.e., the type of
an occurrence correspond to the dependencies and the alias information
from the semantics. 
To show that the type system is sound, we will first introduce the
type rules for values and the relation between the semantics and the
type system. 
After that, we will present some properties in the semantics and type system that are used in the soundness proof.
And lastly, we will show the soundness of the type system. 

\subsection{Type rules for values}
For the sake of proving the type system, we present type rules for the values presented int \cref{sec:EnvSto}, where the type rules is given in \cref{fig:ValTypeRules}.

As the values for closures and recursive closures contains an environment, from where they where declared, as such, before introducing the type rules for values we will present the notion for well-typed environments.

\begin{definition}[Environment judgement]\label{def:TEnv}
	Let $v_1,\cdots,v_n$ be values such that $\Gamma,\Pi\vdash v_i:T_i$, for $1\leq i\leq n$.
	Let $env$ be an environment given by $env=[x_1\mapsto v_1,\cdots,x_n\mapsto v_n]$, $\Gamma$ be a type environment, and $\Pi$ be the approximated order of program points.
	We say that:
	$$\Gamma,\Pi\vdash env$$
	iff 
	\begin{itemize}
		\item For all $x_i\in dom(env)$ then $\exists x_i^p\in dom(\Gamma)$ where $\Gamma(x_i^p)=T_i$ then 
			$$\Gamma,\Pi\vdash env(x_i):T_i$$
	\end{itemize}
\end{definition}

In \cref{def:TEnv} we show the notion of well-typed environments, which states that: given the type of all values, $T_i$, for all variables, $x_i$, bound in the $env$, 
then there exists an occurrence of $x$ in $\Gamma$, where the type from looking up for that occurrences is is $T_i$.
As such, we know that all bindings $x$ in $env$ also have a type in $\Gamma$ from when $x$ were declared.

\begin{description}
	\item[\runa{Constant}] type rule differs from the rule \runa{T-Const}, since most occurrences can evaluate to a constant and as such we know that its type should be a base type.
		Since constants can depend on other occurrences, we know that $\delta$ can be non-empty, but since constants are not locations, we also know that it cannot contain alias information, and as such $\kappa$ should be empty.

	\item[\runa{Location}] type rule represents locations, where we know that it must be a base type.
		Since locations can depend on other occurrences, we know that $\delta$ can be non-empty.
		As locations can contains alias information, and that a location is considered to always be an alias to itself, we know that $\kappa$ can never be empty, as it should always contain an internal variable. 

	\item[\runa{Closure}] type rule represents abstraction, and as such we know that it should have the abstraction type, $T_1\rightarrow T_2$, where we need to make an assumption about the argument type $T_1$.
		Since a closure contains the parameter, body, and the environment for an abstraction from when it were declared, we also need to handle those part in the type rule.
		The components of the closure is handled in the premises, where the environment must be well-typed.
		We also type the body of the abstraction, where we know that we need to update the type environment with the type $T_1$ for its parameter, Where we type the body with $T_2$.

	\item[\runa{Recursive closure}] type rules is similar to the \runa{Closure} rule, but since this is a recursive closure, we additionally need to update the type environment with the name of the recursive binding to the type of the abstraction.

	\item[\runa{Unit}] type rule simply have the base type, as it is not an abstraction and it also cannot have alias information.
		As the unit value is introduced from writing to references, $o=[o_1\;:=\;o_2]^p$, we know that from the type rule \runa{Ref-write} that the dependencies from the occurrence $o$ should also contain the set of occurrences.
		As such, the \runa{Unit} rule also contains a set of occurrences, $\delta$.
\end{description}

\begin{figure}[H]
	\setlength\tabcolsep{8pt}
	\begin{tabular}{l}
		\runa{Constant}\\[0.2cm]
			\inference[]{}
				{\Gamma,\Pi\vdash  c:(\delta, \emptyset)}\\[1cm]

		\runa{Location}\\[0.2cm]
			\inference[]{}
				{\Gamma,\Pi\vdash  \loc:(\delta, \kappa)}\\
				Where $\kappa\neq\emptyset$\\[1cm]

		\runa{Closure}\\[0.2cm]
			\inference[]
				{
					\Gamma,\Pi\vdash env \\
					\Gamma[x^{p}:T_1],\Pi\vdash e^{p'}:T_2
				}
				{\Gamma,\Pi\vdash \left\langle x^{p}, e^{p'}, env \right\rangle^{p''}:T_1\rightarrow T_2}\\[1cm]

		\runa{Recursive closure}\\[0.2cm]
			\inference[]
				{
					\Gamma,\Pi\vdash env \\
					\Gamma[x^{p}:T_1,f^{p'}:T_1\rightarrow T_2],\Pi\vdash e^{p''}:T_2
				}
				{\Gamma,\Pi\vdash \left\langle x^{p}, f^{p'}, e^{p''}, env \right\rangle^{p_3}:T_1\rightarrow T_2}\\[1cm]

		\runa{Unit}\\[0.2cm]
			\inference[]{}
				{\Gamma,\Pi\vdash  ():(\delta,\emptyset)}\\[0.5cm]
	\end{tabular}
	\caption{Type rules for values}
	\label{fig:ValTypeRules}
\end{figure}

\subsection{Agreement}
This section introduces the agreement between the type system and the
semantics, where we will present the relation between the binding
models in the type system and semantics, and show the relation between
them. 

We will first introduce the agreement between the binding models,
i.e., show how the type environment and approximated order of program
points relate to the environment, store, and dependency function. 
Then we will show the type agreement, i.e., show the conditions for when a type agrees with the semantics.
As such, the type agreement needs to show when the dependencies agrees and alias if the alias information agrees with the basis.
 
The first agreement we present is the environment agreement, which ensures that that the type environment and approximated order of program points are a good approximation of the binding model in the semantics, i.e., 
for the environment $env$, store $sto$, dependency function $w$, and the relation of program points over $w$.

Here $env$, $sto$, and $w$ contains information for en evaluation in the semantics, either before or after an evaluation.
The type environment $\Gamma$ contains the local information for variable bindings and global information for internal variables, and the approximated order of program points $\Pi$ is an approximation of all program points in an occurrence.

\begin{definition}[Environment agreement]\label{def:EnvAgree}
	Let $(w,\sqsubseteq_w)$ be a pair containing the dependency function and a relation over it, $env$ be an environment, $sto$ be the a store, $\Gamma$ be a type environment, and $\Pi$ be an approximated program point order.
	We say that:
	$$(env,sto,(w,\sqsubseteq_w))\models(\Gamma,\Pi)$$
	if 
	\begin{enumerate}
		\item $\forall x\in dom(env).(\exists x^p\in dom(w))\wedge(x^p\in dom(w)\Rightarrow \exists x^p\in dom(\Gamma))$
		\item $\forall x^p\in dom(w).x^p\in dom(\Gamma)\Rightarrow env(x)=v\wedge w(x^p)=(L,V)\wedge\Gamma(x^p)=T.\\(env,v,(w,\sqsubseteq_w),(L,V))\models (\Gamma,T)$
		\item $\forall \loc\in dom(sto).(\exists \loc^p\in dom(w))\wedge(\exists \nu x.\forall p\in\{p'\mid\loc^{p'}\in dom(w)\}\Rightarrow\nu x^p\in dom(\Gamma))$
		\item $\forall \loc^p \in dom(w).\exists\nu x^{p}\in dom(\Gamma)\Rightarrow w(\loc^p)=(L,V)\wedge\Gamma(\nu x^{p})=T.(env,\loc,(w,\sqsubseteq_w),(L,V))\models T$
		\item if $p_1\sqsubseteq_w p_2$ then $p_1\sqsubseteq_\Pi p_2$
	\item $\forall \loc^p\in dom(w).\exists \nu x^p\in dom(\Gamma)\Rightarrow\exists p'\in\cat{P}.uf_{\sqsubseteq_w}(\loc,w)\in uf_{\Upsilon_{p'}}(\nu x,\Gamma)$
	\end{enumerate}
\end{definition}
The idea behind the environment agreement is that we need to make sure that semantics and type system talks about the same, i.e., if the dependencies in the semantics is also captured in the type environment, the alias information is captured, 
that $\Pi$ is a good approximation, in respect to $w$, and the $p$-chains captures the global occurrence.
As such, the type environment focuses on three areas: \cat{1)} local information variables, \cat{2)} the global information for references, and \cat{3)} the approximated order of program points.
It should be noted at the agreement only relates the information known by $env$, $sto$, and $w$.

\begin{description}
	\item[1)] The agreement for local information only relates the information currently known by $env$, and that the information known by $w$ and $\Gamma$ agrees, in respect to \cref{def:TAgree}.
		This is ensured by \cat{1)} and \cat{2)}.

	\item[2)] We similarly handles agreement for the global information known, which is ensured by \cat{3)} and \cat{4)}.
		Since $\Gamma$ contains the global information for references, we require that there exists a corresponding internal variable to the currently known locations, by comparing them by program points.
		We also ensures that the dependencies from a location occurrence agrees with the type of a corresponding internal variable occurrence, in respect to \cref{def:TAgree}.

	\item[3)] We also needs to ensure that $\Pi$ is a good approximation of the order $\sqsubseteq_w$ and the greatest binding function for $p$-chains ensures that we always get the necessary reference occurrences.
	\cat{5)} ensures that if an order is defined in $\sqsubseteq_w$, then $\Pi$ also agrees on this order.

	For \cat{6)}, we need to ensure that for any location currently known the exists a corresponding internal variable where, getting the greatest binding of this occurrence, $\loc^p$, then there exists a program point $p'$, 
	such that looking up all greatest bindings for the $p'$-chain, there exists an internal variable occurrence that corresponds to $\loc^p$.
\end{description}
\bigskip

With the environment agreement defined, we can present the type agreement.
As the type can be abstractions and base types, with or without alias information, we have different requirements for handling them, as such we relate each requirement to a value
Here, the idea is that if the value is a location, then we check that both the set of occurrences agrees with the dependency pair, presented in \cref{def:DepAgree}, 
and check if the alias information agrees with the semantics, \cref{def:AliasAgree}.
If the value is not a location, then the type can either be an abstraction type or base type.
For the base type, we check that the agreement between the set of occurrences and the dependency pair agrees.
If the type is an abstraction, then we check that $T_2$ agrees with binding model.
We are only concerned about the return type $T_2$ for abstractions, since if the argument parameter is used in the body of the abstraction, then the dependencies would already be part of the return type.

\begin{definition}[Type agreement]\label{def:TAgree}
	Let $env$ be an environment, $w$ be a dependency function, $\sqsubseteq_w$ be a relation over $w$, $(L,V)$ be a dependency pair, and $T$ be a type.
	We say that:
	$$(env,v,(w,\sqsubseteq_w),(L,V))\models(\Gamma,T)$$
	iff
	\begin{itemize}
		\item $v\neq\loc$ and $T=T_1\rightarrow T_2$:
		\begin{itemize}
			\item $(env,v,(w,\sqsubseteq_w),(L,V))\models(\Gamma,T_2)$
		\end{itemize}

		\item $v\neq\loc$ and $T=(\delta,\kappa)$:
		\begin{itemize}
			\item $(env,(L,V))\models\delta$
		\end{itemize}

		\item $v=\loc$ then $T=(\delta,\kappa)$ where:
		\begin{itemize}
			\item $(env,(L,V))\models\delta$
			\item $(env,(w,\sqsubseteq_w),v)\models(\Gamma,\kappa)$
		\end{itemize}
	\end{itemize}
\end{definition}

\begin{definition}[Dependency agreement]\label{def:DepAgree}
	Let $env$ be an environment, $(L,V)$ be a dependency pair, and $\delta$ be a set of occurrences.
	We say that:
	$$(env,(L,V))\models\delta$$
	if
	\begin{itemize}
		\item $V\subseteq\delta$,
		\item For all $\loc^p\in L$ where $env^{\loc}\neq\emptyset$, we then have $\{x\in dom(env)\mid env(x)=\loc\}\subseteq \kappa_i^0$ for a $\kappa_i^0\in\delta$
		\item For all $\loc^p\in L$ where $env^{\loc}=\emptyset$ then there exists a $\kappa_i^0\in\delta$ such that $\kappa_i^0\subseteq\cat{IVar}$
	\end{itemize}
\end{definition}

The dependency agreement, defined in \cref{def:DepAgree}, ensures that $\delta$ at leas contains all information from the dependency pair.


\begin{definition}[Alias agreement]\label{def:AliasAgree}
	Let $env$ be an environment, $w$ be a pair of a dependency function, $\sqsubseteq_w$ be a relation over $w$, $\loc$ be a location, and $\kappa$ be an alias set.
	We say that:
	$$(env,(w,\sqsubseteq_w),\loc)\models(\Gamma,\kappa)$$
	if
	\begin{itemize}
		\item $\exists \loc^p\in dom(w).\nu x^p\in dom(\Gamma)\Rightarrow\nu x\in\kappa$
		\item $env^{-1}(\loc)\neq\emptyset.\exists \kappa^0_i\in\kappa^0\Rightarrow
			(env^{-1}(\loc)\subseteq\kappa^0_i)\wedge(\exists \loc^p\in dom(w).\nu x^p\in dom(\Gamma)\Rightarrow\\\nu x\in\kappa^0_i\wedge\nu x\in\kappa)$
		\item $env^{-1}(\loc)=\emptyset.\exists \kappa^0_i\in\kappa^0\Rightarrow
			(\exists \loc^p\in dom(w).\nu x^p\in dom(\Gamma)\Rightarrow\nu x\in\kappa^0_i\wedge\nu x\in\kappa)$
	\end{itemize}
\end{definition}

The alias agreement, defined in \cref{def:AliasAgree}, ensures that the alias information in $\kappa$ is also known the environment.
To do this, we ensure that if there exists alias information in the environment $env$, then there exists an alias base $\kappa^0_i\in\kappa^0$ such that the currently know alias information known in 
in $env$ is a subset of $\kappa^0_i$, and that there exists a $\nu x\in\kappa$, such that $\nu x\in \kappa^0_i$.
If there is no currently known alias information, we simply check that there exists a corresponding internal variable, that is part of an alias base.

\subsection{Properties}
Before we present the soundness proof, we will first present some properties about the semantics and type system.
The first property we present is for the dependency function,since the dependency function is global, and as such they can contain side effects after an evaluation.
This property states that if any new variable bindings is introduced to the dependency function, by evaluating an occurrence $e^p$, those variables are not free in $e^p$.

\begin{lemma}[History]\label{lemma:His}
	Suppose $e^p$ is an occurrence, that
	$$env\vdash\left\langle e^{p},sto,(w,\sqsubseteq_w),p'\right\rangle\rightarrow\left\langle v,sto',(w',\sqsubseteq_w'),(L,V),p''\right\rangle$$
		and $x^{p_1}\in dom(w')\backslash dom(w)$.
		Then $x\notin fv(e^{p})$
\end{lemma}
%The proof for \cref{lemma:His} can be found in \cref{app:HisProof}.

%\subfile{HisProof/index.tex}

The second property is the strengthening of the type environment, which states that if there is a binding the type environment, used to type an occurrence $e^p$, and the variables is not free in $e^p$ then the binding can be removed.

\begin{lemma}[Strengthening]\label{lemma:Strength}
	If $\Gamma[x^{p'}:T'],\Pi\vdash e^{p}:T$ and $x\notin fv(e^p)$, then $\Gamma,\Pi\vdash e^{p}:T$
\end{lemma}
%The proof for \cref{lemma:Strength} can be found in \cref{app:StrProof}.
%\subfile{StrProof/index.tex}

With history, \cref{lemma:His}, and strengthening,
\cref{lemma:Strength}, defined we can how present the soundness
theorem for our type system.

This theorem compares the semantics to the type system and shows that
it is a sound approximation of the type system.

Here we need to make sure that an
evaluation of an occurrence, and the type for the occurrence agrees. 
As such, we assume that the type environment and approximated order of
program points are in an agreement with the binding models in the
semantics, and we also assume that the environment is well-typed. 

Based on these assumptions, we then need to make sure that, after an
evaluation, we are still in agreement, we can type the value, and the
type is in agreement with the semantics. 

\begin{theorem}[Soundness of type system]
	Suppose $e^{p'}$ is an occurrence where
	\begin{itemize}
		\item $env\vdash\left\langle e^{p'},sto,(w,\sqsubseteq_w),p\right\rangle\rightarrow\left\langle v,sto',(w',\sqsubseteq_w'),(L,V),p''\right\rangle$,
		\item $\Gamma,\Pi\vdash e^{p'} : T$
		\item $\Gamma,\Pi\vdash env$
		\item $(env,sto,(w,\sqsubseteq_w))\models(\Gamma,\Pi)$
	\end{itemize}
	Then we have that:
	\begin{itemize}
		\item $\Gamma,\Pi\vdash v:T$
		\item $(env,sto',(w',\sqsubseteq_w'))\models(\Gamma,\Pi)$
		\item $(env,(w',\sqsubseteq_w'),v,(L,V))\models(\Gamma,T)$
	\end{itemize}
\end{theorem}
\begin{proof}
	The proof proceeds by induction on the height of the derivation tree for 
	$$env\vdash\left\langle e^{p'},sto,\psi,p\right\rangle\rightarrow\left\langle v,sto',\psi',(L,V),p''\right\rangle$$
	We will only show the proof of four rules here, for \runa{Var}, \runa{Case}, \runa{Ref}, and \runa{Ref-write}.% , the full proof can be found in \cref{app:SoundnessProof}.

	% \begin{description}
	% 	\input{sections/Proof/SoundProof/var.tex}
	% 	\input{sections/Proof/SoundProof/case.tex}
	% 	\input{sections/Proof/SoundProof/refread.tex}
	% \end{description}
\end{proof}

% \subfile{SoundProof/index.tex}

\section{Conclusion}\label{sec:Conc}

We have introduced a type system for local data-flow analysis for a
subset of ReScript. 

In the type system, we have shown how to handle data-flow analysis for
different language constructs, for pattern matching, local
declarations, and referencing. 
As pattern matching introduces branches to the language, we showed a
sound over-approximation of how to handle these branches. 
Additionally, since we also have mutability, through referencing, the approximation should also, in case of reading from a reference, get all places where a reference binding could exist in the type environment.
Since some branches could write to a reference, while others do not, it was important to consider each branch separately when reading from references.

\subsection{Discussion}

The type system we have presented is for a small language without many
constructs. 
However, some interesting constructs were introduced to the language,
such as mutability and pattern matching which introduces some
challenges when trying to make a good approximation of data-flow. 

The challenges from having both pattern matching and mutability introduced challenges, as each branch could not simply be thought of as locally, since reference operations introduce side effects.
To references, we represent them as internal variables, i.e., variables that do not exist in the syntax, and treating them as global information.
To handle the problem of branching, when reading from a reference, we look at each branch independently to find the information necessary.
\bigskip

Since we focused on a functional language, that is based on
expressions, we focused the data-flow analysis on the flow of
variables, i.e., which variables are used to evaluate an occurrence.
As the language is primarily a series of declaration of functions,
variables, and references, this allows for analyzing where variables
are used on which are useful evaluating an occurrence.

Additionally by representing referencing as internal variables, it
allows for understanding of which references are used and where they
are used in the occurrence.  This information can be used by compilers
to make sure that references can be safely cleaned up, after the last
place they were used.  The alias information also implies which
aliases were used in the occurrence.

However, the type system introduced contains some restrictions, also
called slack, for which occurrences it accepts.  As the type system
does not allow for type polymorphism, the use cases for abstractions
are restricted.  In one place, where abstractions are quite limited is
when binding them to a local declaration, this local declaration
cannot be used at multiple places, as this would mean it would contain
occurrences at multiple program points.

Another area of the type system contains slack, is for references as abstractions cannot be bound to them.
Here, another issue occurs as the environment only contains local information, and an abstraction thus only knows about the variables known when it was declared.
As the type system is currently defined, the type environment should be bound with the abstraction, but the current type system does not allow this, as the type environment both includes local and global information.


\subsection{Future work}\label{sec:FW}

\paragraph{Implementation of a type checker}
Implementing a type checker for the type system presented here would allow for testing how well the information is used.
It would also allow for comparing how well it performs, compared to other data-flow analysis techniques.

\paragraph{Polymorphism}

A next step is that of introducing polymorphism. Polymorphism for the
base type $(\delta,\kappa)$ would allow for abstractions to be used
multiple times in an occurrence ad the input and output type would not
be restricted from only allowing the exact same input type.

Consider the following occurrence.

\begin{lstlisting}[language=Caml, mathescape=true]
(let x ($\lambda$ y.y$^1$)$^2$ (x$^3$ (x$^4$ 1$^5$)$^6$)$^7$)$^8$
\end{lstlisting}

If polymorphism is introduced, occurrences like this could be defined,
since when typing the applications, the type of the argument changes,
since the occurrence $x^4$ is present in the second application. 


\paragraph{Extending references}
References are defined currently in the type system, they cannot be bound to abstractions.
However, this would also introduce complications, as abstractions need the information known at the time they were declared.
Another complication would be that if different references had different types, e.g., if it had an abstraction type at one point and a base type at another point.
Here, either we should require references to always have the same type, e.g., with base type polymorphism.
Consider the following occurrence:
\begin{lstlisting}[language=Caml, mathescape=true]
((!(case 1 (1$^1$) (let z 5$^2$ (ref ($\lambda$ y.(PLUS z$^3$ y$^4$)$^5$)$^6$))$^7$)$^8$)$^9$ 5)$^{10}$
\end{lstlisting}
This occurrence would create a reference to a local abstraction which depends on the locally declared variable $z$ before reading from the reference and applying the constant to it.
In the semantics, the environment would be added to the abstraction closure, and when evaluating the body of the abstraction, in an application, it would use the environment in the closure.

\paragraph{Type inference}
Another area is to make a type inference algorithm, which can find the type information.
To make type inference for the type system would need to find an approximated order of program points, find a proper $\kappa_0$ and type for abstractions, that is, find all the places where the parameter should be bound.

\paragraph{Extending with more language constructs}
It would also be interesting to introduce more language constructs, as the language presented only contains a small amount of constructs, such as mutability and pattern matching.
Some interesting constructs to add could be records, constructors and deconstructors, modules, or lazy evaluation.
Here, lazy evaluation could take multiple forms, either by introducing it as a core part of the language, where every binding is lazy evaluated, or add special constructs for lazy evaluation.
Modules, on the other hand, would allow for wrapping an occurrence, or multiple occurrences into a module, which could then be used in multiple places.

\bibliography{bib}
\bibliographystyle{plain}
\end{document}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
